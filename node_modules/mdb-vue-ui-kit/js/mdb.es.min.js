import { defineComponent as A, useAttrs as et, computed as f, openBlock as d, createBlock as V, resolveDynamicComponent as N, normalizeClass as g, withCtx as D, renderSlot as O, ref as p, withDirectives as ke, unref as q, createElementBlock as b, Fragment as ge, mergeProps as Q, createCommentVNode as C, onMounted as de, onUnmounted as $e, watch as ee, withKeys as xt, renderList as Ct, createElementVNode as H, toDisplayString as z, normalizeStyle as le, inject as Z, watchEffect as fe, provide as te, Transition as Ne, vShow as Wt, reactive as ia, nextTick as je, createVNode as Oe, Teleport as ua, useSlots as ca, onBeforeUnmount as da, withModifiers as ze, createTextVNode as fa, resolveComponent as va, KeepAlive as pa, onUpdated as Ht, vModelRadio as Mt } from "vue";
const ma = {
  name: "MDBBadge"
}, Cr = /* @__PURE__ */ A({
  ...ma,
  props: {
    badge: String,
    color: String,
    pill: Boolean,
    dot: Boolean,
    notification: Boolean,
    tag: {
      type: String,
      default: "span"
    }
  },
  setup(e, { expose: t }) {
    const a = e, l = et(), n = f(() => [
      "badge",
      a.color && `badge-${a.color}`,
      a.badge && `bg-${a.badge}`,
      a.pill && "rounded-pill",
      a.dot && "badge-dot",
      a.notification && "badge-notification"
    ]);
    return t({ attrs: l }), (o, r) => (d(), V(N(e.tag), {
      class: g(n.value)
    }, {
      default: D(() => [
        O(o.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), ga = [
  "primary",
  "secondary",
  "success",
  "danger",
  "warning",
  "info",
  "light",
  "dark"
], ha = "rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%", ya = [0, 0, 0], Vt = 0.5, ba = (e) => e && ga.includes(e.toLowerCase()), wa = (e, t) => {
  const a = (o) => (o.length < 7 && (o = `#${o[1]}${o[1]}${o[2]}${o[2]}${o[3]}${o[3]}`), [
    parseInt(o.substr(1, 2), 16),
    parseInt(o.substr(3, 2), 16),
    parseInt(o.substr(5, 2), 16)
  ]), l = (o) => {
    const r = document.body.appendChild(
      document.createElement("fictum")
    ), s = "rgb(1, 2, 3)";
    return r.style.color = s, r.style.color !== s || (r.style.color = o, r.style.color === s || r.style.color === "") ? (document.body.removeChild(r), t) : (o = getComputedStyle(r).color, document.body.removeChild(r), o);
  }, n = (o) => {
    const r = o.match(/[.\d]+/g);
    if (r === null)
      return;
    const s = r.map((u) => +Number(u));
    return s.length = 3, s;
  };
  return typeof e == "string" && e.toLowerCase() === "transparent" ? t : typeof e == "string" && e[0] === "#" ? a(e) : (typeof e == "string" && e.indexOf("rgb") === -1 && (e = l(e)), typeof e == "string" && e.indexOf("rgb") === 0 ? n(e) : t);
}, ka = ({ offsetX: e, offsetY: t, height: a, width: l }) => {
  const n = t <= a / 2, o = e <= l / 2, r = (m, $) => Math.sqrt(m ** 2 + $ ** 2), s = t === a / 2 && e === l / 2, u = {
    first: n === !0 && o === !1,
    second: n === !0 && o === !0,
    third: n === !1 && o === !0,
    fourth: n === !1 && o === !1
  }, c = {
    topLeft: r(e, t),
    topRight: r(l - e, t),
    bottomLeft: r(e, a - t),
    bottomRight: r(l - e, a - t)
  };
  let i = 0;
  return s || u.fourth ? i = c.topLeft : u.third ? i = c.topRight : u.second ? i = c.bottomRight : u.first && (i = c.bottomLeft), i * 2;
}, Ba = (e, t) => {
  for (const a in t)
    e.style[a] = t[a];
}, $a = (e) => {
  const t = wa(e, ya);
  if (e !== "" && t) {
    const a = t.join(",");
    return `radial-gradient(circle, ${ha.split("{{color}}").join(`${a}`)})`;
  }
}, Sa = (e, t, a) => {
  const l = document.createElement("div");
  l.classList.add("ripple-wave");
  const n = {
    offsetX: a.centered ? t.height / 2 : t.left,
    offsetY: a.centered ? t.width / 2 : t.top,
    height: t.height,
    width: t.width
  }, o = ka(n), r = a.radius || o / 2, s = {
    delay: a.duration && a.duration * Vt,
    duration: a.duration && a.duration - a.duration * Vt
  }, u = {
    left: a.centered ? `${Math.round(t.width / 2 - r)}px` : `${Math.round(t.left - r)}px`,
    top: a.centered ? `${Math.round(t.height / 2 - r)}px` : `${Math.round(t.top - r)}px`,
    height: `${Math.round(
      a.radius && a.radius * 2 || o
    )}px`,
    width: `${Math.round(
      a.radius && a.radius * 2 || o
    )}px`,
    transitionDelay: `0s, ${s.delay}ms`,
    transitionDuration: `${a.duration}ms, ${s.duration}ms`
  };
  a.unbound && e.classList.add("ripple-surface-unbound"), ba(a.color) ? e.classList.add(`ripple-surface-${a.color}`) : u.backgroundImage = $a(a.color), Ba(l, u), e.appendChild(l), setTimeout(() => {
    l.classList.add("active");
  }, 50), setTimeout(
    () => {
      e.removeChild(l);
    },
    a.duration ? a.duration + 1e3 : 1e3
  );
}, it = {
  mounted(e, t) {
    if (t.value === !1)
      return;
    const a = {
      centered: t.value && t.value.centered || !1,
      color: t.value && t.value.color || "",
      duration: t.value && t.value.duration || 500,
      radius: t.value && t.value.radius || 0,
      unbound: t.value && t.value.unbound || !1
    };
    e.classList.add("ripple-surface"), e.waves = (l) => {
      const n = {
        top: l.offsetY,
        left: l.offsetX,
        height: e.offsetHeight,
        width: e.offsetWidth
      };
      Sa(e, n, a);
    }, e.addEventListener("click", (l) => e.waves(l));
  },
  updated(e, t) {
    t.value !== !1 && (e.classList.contains("ripple-surface") || e.classList.add("ripple-surface"));
  },
  unmounted(e) {
    e.removeEventListener("click", (t) => e.waves(t));
  }
}, xa = {
  name: "MDBBtn"
}, Ca = /* @__PURE__ */ A({
  ...xa,
  props: {
    color: String,
    size: String,
    outline: String,
    rounded: Boolean,
    floating: Boolean,
    toggler: Boolean,
    toggle: Boolean,
    role: {
      type: String,
      default: "button"
    },
    type: {
      type: String,
      default: "button"
    },
    tag: {
      type: String,
      default: "button"
    },
    block: {
      type: Boolean,
      default: !1
    },
    ripple: {
      type: [Object, Boolean],
      default: (e) => e.outline || e.color === "light" || e.color === "link" ? { color: "dark" } : !0
    },
    picker: Boolean
  },
  emits: ["update:toggle"],
  setup(e, { emit: t }) {
    const a = e, l = p(a.toggle), n = f(() => [
      !a.picker && "btn",
      a.color && `btn-${a.color}`,
      a.size && `btn-${a.size}`,
      a.outline && `btn-outline-${a.outline}`,
      a.rounded && "btn-rounded",
      a.floating && "btn-floating",
      a.block && "btn-block",
      l.value && "active"
    ]), o = () => {
      a.toggler && (l.value = !l.value, t("update:toggle", l.value));
    };
    return (r, s) => ke((d(), V(N(e.tag), {
      type: e.type,
      role: e.role,
      class: g(n.value),
      onClick: o
    }, {
      default: D(() => [
        O(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["type", "role", "class"])), [
      [q(it), e.ripple]
    ]);
  }
}), Ma = {
  name: "MDBBtnGroup"
}, Mr = /* @__PURE__ */ A({
  ...Ma,
  props: {
    size: String,
    vertical: Boolean,
    role: {
      type: String,
      default: "group"
    },
    tag: {
      type: String,
      default: "div"
    }
  },
  setup(e) {
    const t = e, a = f(() => [
      t.size && `btn-group-${t.size}`,
      t.vertical ? "btn-group-vertical" : "btn-group"
    ]);
    return (l, n) => (d(), V(N(e.tag), {
      class: g(a.value),
      role: e.role
    }, {
      default: D(() => [
        O(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "role"]));
  }
}), Va = {
  name: "MDBBtnClose"
}, Da = /* @__PURE__ */ A({
  ...Va,
  props: {
    white: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    const t = e, a = f(() => ["btn-close", t.white && "btn-close-white"]);
    return (l, n) => (d(), b("button", {
      class: g(a.value),
      "aria-label": "Close"
    }, null, 2));
  }
}), Oa = {
  name: "MDBCard"
}, Vr = /* @__PURE__ */ A({
  ...Oa,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    border: String,
    bg: String,
    text: [String, Array],
    shadow: String
  },
  setup(e) {
    const t = e, a = f(() => [
      "card",
      t.border && `border border-${t.border}`,
      t.bg && `bg-${t.bg}`,
      t.shadow && `shadow-${t.shadow}`,
      t.text && l(t.text)
    ]), l = (n) => typeof n == "string" ? `text-${n}` : n.map((o) => `text-${o}`.trim()).join(" ");
    return (n, o) => (d(), V(N(e.tag), {
      class: g(a.value)
    }, {
      default: D(() => [
        O(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Ea = {
  name: "MDBCardBody"
}, Dr = /* @__PURE__ */ A({
  ...Ea,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    text: {
      type: [String, Array]
    }
  },
  setup(e) {
    const t = e, a = f(() => ["card-body", t.text && l(t.text)]), l = (n) => typeof n == "string" ? `text-${n}` : n.map((o) => `text-${o}`.trim()).join(" ");
    return (n, o) => (d(), V(N(e.tag), {
      class: g(a.value)
    }, {
      default: D(() => [
        O(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Na = {
  name: "MDBCardTitle"
}, Or = /* @__PURE__ */ A({
  ...Na,
  props: {
    tag: {
      type: String,
      default: "h5"
    },
    subtitle: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    const t = e, a = f(() => t.subtitle ? t.tag !== "h5" ? t.tag : "h6" : t.tag), l = f(() => [t.subtitle ? "card-subtitle" : "card-title"]);
    return (n, o) => (d(), V(N(a.value), {
      class: g(l.value)
    }, {
      default: D(() => [
        O(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Ta = {
  name: "MDBCardText"
}, Er = /* @__PURE__ */ A({
  ...Ta,
  props: {
    tag: {
      type: String,
      default: "p"
    }
  },
  setup(e) {
    const t = f(() => ["card-text"]);
    return (a, l) => (d(), V(N(e.tag), {
      class: g(t.value)
    }, {
      default: D(() => [
        O(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Aa = {
  name: "MDBCardImg"
}, Nr = /* @__PURE__ */ A({
  ...Aa,
  props: {
    tag: {
      type: String,
      default: "img"
    },
    src: {
      type: String,
      required: !0
    },
    alt: String,
    top: {
      type: Boolean,
      default: !1
    },
    bottom: {
      type: Boolean,
      default: !1
    },
    fluid: {
      type: Boolean,
      default: !1
    },
    overlay: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    const t = e, a = f(() => [
      t.top && "card-img-top",
      t.bottom && "card-img-bottom",
      t.fluid && "img-fluid",
      t.overlay && "card-img",
      !t.top && !t.bottom && !t.fluid && !t.overlay && "card-img"
    ]);
    return (l, n) => (d(), b(ge, null, [
      (d(), V(N(e.tag), Q({
        src: e.src,
        alt: e.alt,
        class: a.value
      }, l.$attrs), null, 16, ["src", "alt", "class"])),
      e.overlay ? (d(), b("div", Q({
        key: 0,
        class: "card-img-overlay"
      }, l.$attrs), [
        O(l.$slots, "default")
      ], 16)) : C("", !0)
    ], 64));
  }
}), La = {
  name: "MDBCardHeader"
}, Tr = /* @__PURE__ */ A({
  ...La,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    bg: String,
    border: String
  },
  setup(e) {
    const t = e, a = f(() => [
      "card-header",
      t.border && `border-${t.border}`,
      t.bg && `bg-${t.bg}`
    ]);
    return (l, n) => (d(), V(N(e.tag), {
      class: g(a.value)
    }, {
      default: D(() => [
        O(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), _a = {
  name: "MDBCardFooter"
}, Ar = /* @__PURE__ */ A({
  ..._a,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    bg: String,
    border: String
  },
  setup(e) {
    const t = e, a = f(() => [
      "card-footer",
      t.border && `border-${t.border}`,
      t.bg && `bg-${t.bg}`
    ]);
    return (l, n) => (d(), V(N(e.tag), {
      class: g(a.value)
    }, {
      default: D(() => [
        O(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Ia = {
  name: "MDBCardLink"
}, Lr = /* @__PURE__ */ A({
  ...Ia,
  props: {
    tag: {
      type: String,
      default: "a"
    }
  },
  setup(e) {
    const t = f(() => ["card-link"]);
    return (a, l) => (d(), V(N(e.tag), {
      class: g(t.value)
    }, {
      default: D(() => [
        O(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Pa = {
  name: "MDBCardGroup"
}, _r = /* @__PURE__ */ A({
  ...Pa,
  props: {
    tag: {
      type: String,
      default: "div"
    }
  },
  setup(e) {
    const t = f(() => ["card-group"]);
    return (a, l) => (d(), V(N(e.tag), {
      class: g(t.value)
    }, {
      default: D(() => [
        O(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Fa = {
  key: 0,
  class: "carousel-indicators"
}, Ra = ["ariaCurrent", "ariaLabel", "onClick"], qa = {
  key: 0,
  class: "img-fluid",
  autoplay: "",
  loop: "",
  muted: ""
}, ja = ["src", "type"], za = ["src", "alt"], Wa = { key: 0 }, Ha = { key: 1 }, Ga = /* @__PURE__ */ H("span", {
  class: "carousel-control-prev-icon",
  "aria-hidden": "true"
}, null, -1), Ua = /* @__PURE__ */ H("span", { class: "visually-hidden" }, "Previous", -1), Xa = [
  Ga,
  Ua
], Ya = /* @__PURE__ */ H("span", {
  class: "carousel-control-next-icon",
  "aria-hidden": "true"
}, null, -1), Ka = /* @__PURE__ */ H("span", { class: "visually-hidden" }, "Next", -1), Ja = [
  Ya,
  Ka
], Qa = {
  name: "MDBCarousel"
}, Ir = /* @__PURE__ */ A({
  ...Qa,
  props: {
    captionsClass: {
      type: String,
      default: "carousel-caption d-none d-md-block"
    },
    controls: {
      type: Boolean,
      default: !0
    },
    dark: Boolean,
    fade: Boolean,
    indicators: {
      type: Boolean,
      default: !0
    },
    interval: {
      type: [Number, Boolean],
      default: 5e3
    },
    items: Array,
    itemsClass: {
      type: String,
      default: "d-block w-100"
    },
    keyboard: {
      type: Boolean,
      default: !0
    },
    modelValue: {
      type: Number,
      default: 0
    },
    pause: {
      type: [String, Boolean],
      default: "hover"
    },
    tag: {
      type: String,
      default: "div"
    },
    touch: {
      type: Boolean,
      default: !0
    },
    innerClass: String
  },
  emits: ["update:modelValue"],
  setup(e, { expose: t, emit: a }) {
    const l = e, n = f(() => [
      "carousel",
      "slide",
      l.fade && "carousel-fade",
      l.dark && "carousel-dark"
    ]), o = f(() => ["carousel-inner", l.innerClass]), r = p(l.modelValue), s = p(null), u = p(!1);
    let c, i = !1;
    const m = () => {
      v("prev");
    }, $ = () => {
      v("next");
    }, v = (B) => {
      if (u.value)
        return;
      const j = i;
      i = !1, y(B), i = j;
    }, y = (B) => {
      if (i || !s.value)
        return;
      u.value = !0;
      const j = S(B), X = h(B), Y = k(X), se = L(X), ie = M(r.value), ue = M(j);
      r.value = j, ue.classList.add(se), a("update:modelValue", r.value), l.interval && w(), setTimeout(() => {
        ie.classList.add(Y), ue.classList.add(Y);
      }, 20), setTimeout(() => {
        ie.classList.remove("active"), ie.classList.remove(Y), ue.classList.remove(Y), ue.classList.remove(se), ue.classList.add("active"), u.value = !1;
      }, 600);
    }, S = (B) => {
      const j = l.items || [];
      return B === "prev" && r.value <= 0 ? j.length - 1 : B === "prev" ? r.value - 1 : B === "next" && r.value >= j.length - 1 ? 0 : B === "next" ? r.value + 1 : B;
    }, h = (B) => B === "next" || typeof B == "number" && B > r.value, k = (B) => B ? "carousel-item-start" : "carousel-item-end", L = (B) => B ? "carousel-item-next" : "carousel-item-prev", M = (B) => s.value.querySelectorAll(".carousel-item")[B], w = () => {
      clearInterval(c), c = void 0;
      const B = l.items && l.items[r.value].interval || l.interval;
      c = setInterval(() => {
        y("next");
      }, B);
    }, T = () => {
      l.pause === "hover" && l.interval && (clearInterval(c), c = void 0, i = !0);
    }, I = () => {
      l.pause === "hover" && l.interval && (w(), i = !1);
    }, R = () => {
      l.keyboard && $();
    }, W = () => {
      l.keyboard && m();
    }, G = !!window.PointerEvent, F = p(0), E = p(0), P = (B) => {
      if (!l.touch)
        return;
      const j = B, X = B, Y = B;
      G && (j.pointerType === "pen" || j.pointerType === "touch") ? F.value = X.clientX : F.value = Y.touches[0].clientX;
    }, x = (B) => {
      l.touch && (E.value = B.touches && B.touches.length > 1 ? 0 : B.touches[0].clientX - F.value);
    }, _ = (B) => {
      if (!l.touch)
        return;
      const j = B, X = B;
      G && (j.pointerType === "pen" || j.pointerType === "touch") && (E.value = X.clientX - F.value), K();
    }, K = () => {
      const B = Math.abs(E.value);
      if (B <= 40)
        return;
      const j = B / E.value;
      E.value = 0, j && (j > 0 ? m() : $());
    };
    return de(() => {
      var j;
      const B = (j = s.value) == null ? void 0 : j.querySelectorAll(".carousel-item")[r.value];
      B == null || B.classList.add("active"), l.interval && w();
    }), $e(() => {
      l.interval && (clearInterval(c), c = void 0);
    }), ee(
      () => l.modelValue,
      (B) => v(B)
    ), t({ next: $, prev: m }), (B, j) => (d(), V(N(e.tag), {
      class: g(n.value),
      onMouseenter: T,
      onMouseleave: I,
      onKeydown: [
        xt(R, ["right"]),
        xt(W, ["left"])
      ],
      onTouchstart: P,
      onTouchmove: x,
      onTouchend: _
    }, {
      default: D(() => [
        e.indicators ? (d(), b("div", Fa, [
          (d(!0), b(ge, null, Ct(e.items, (X, Y) => (d(), b("button", {
            key: Y,
            type: "button",
            class: g(r.value === Y && "active"),
            ariaCurrent: r.value === Y && "true",
            ariaLabel: `Slide ${Y + 1}`,
            onClick: (se) => v(Y)
          }, null, 10, Ra))), 128))
        ])) : C("", !0),
        H("div", {
          class: g(o.value),
          ref_key: "carouselInnerRef",
          ref: s
        }, [
          (d(!0), b(ge, null, Ct(e.items, (X, Y) => (d(), b("div", {
            class: "carousel-item",
            key: Y
          }, [
            X.video ? (d(), b("video", qa, [
              H("source", {
                src: X.video,
                type: X.videoType
              }, null, 8, ja)
            ])) : (d(), b("img", {
              key: 1,
              src: X.src,
              alt: X.alt,
              class: g(e.itemsClass)
            }, null, 10, za)),
            X.label || X.caption ? (d(), b("div", {
              key: 2,
              class: g(e.captionsClass)
            }, [
              X.label ? (d(), b("h5", Wa, z(X.label), 1)) : C("", !0),
              X.caption ? (d(), b("p", Ha, z(X.caption), 1)) : C("", !0)
            ], 2)) : C("", !0)
          ]))), 128))
        ], 2),
        e.controls ? (d(), b("button", {
          key: 1,
          onClick: m,
          class: "carousel-control-prev",
          type: "button"
        }, Xa)) : C("", !0),
        e.controls ? (d(), b("button", {
          key: 2,
          onClick: $,
          class: "carousel-control-next",
          type: "button"
        }, Ja)) : C("", !0)
      ]),
      _: 1
    }, 40, ["class", "onKeydown"]));
  }
}), Za = {
  name: "MDBListGroup"
}, Pr = /* @__PURE__ */ A({
  ...Za,
  props: {
    flush: {
      type: Boolean,
      default: !1
    },
    horizontal: {
      type: [Boolean, String],
      default: !1
    },
    numbered: Boolean,
    tag: {
      type: String,
      default: "ul"
    },
    light: Boolean,
    small: Boolean
  },
  setup(e) {
    const t = e, a = f(() => [
      "list-group",
      t.horizontal && l.value,
      t.flush && "list-group-flush",
      t.numbered && "list-group-numbered",
      t.light && "list-group-light",
      t.small && "list-group-small"
    ]), l = f(() => {
      if (t.horizontal)
        return t.horizontal !== !0 ? `list-group-horizontal-${t.horizontal}` : "list-group-horizontal";
    });
    return (n, o) => (d(), V(N(e.tag), {
      class: g(a.value)
    }, {
      default: D(() => [
        O(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), el = {
  name: "MDBListGroupItem"
}, Fr = /* @__PURE__ */ A({
  ...el,
  props: {
    tag: {
      type: String,
      default: "li"
    },
    active: {
      type: Boolean,
      default: !1
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    action: {
      type: Boolean,
      default: !1
    },
    color: String,
    noBorder: Boolean,
    spacing: {
      type: [Boolean, String],
      default: !1
    },
    ripple: {
      type: [Object, Boolean],
      default: !1
    }
  },
  setup(e) {
    const t = e, a = f(() => {
      if (t.spacing)
        return t.spacing !== !0 ? t.spacing : "px-3";
    }), l = f(() => [
      "list-group-item",
      t.active && "active",
      t.disabled && "disabled",
      t.action && "list-group-item-action",
      t.color && `list-group-item-${t.color}`,
      t.noBorder && "border-0",
      t.spacing && a.value
    ]);
    return (n, o) => ke((d(), V(N(e.tag), {
      class: g(l.value),
      "aria-current": e.active ? !0 : null,
      "aria-disabled": e.disabled ? !0 : null,
      disabled: e.disabled ? !0 : null
    }, {
      default: D(() => [
        O(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "aria-current", "aria-disabled", "disabled"])), [
      [q(it), t.ripple]
    ]);
  }
}), tl = {
  name: "MDBProgress"
}, Rr = /* @__PURE__ */ A({
  ...tl,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    height: Number
  },
  setup(e) {
    const t = e, a = f(() => ["progress"]), l = f(() => ({ height: t.height + "px" }));
    return (n, o) => (d(), V(N(e.tag), {
      class: g(a.value),
      style: le(l.value)
    }, {
      default: D(() => [
        O(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "style"]));
  }
}), al = {
  name: "MDBProgressBar"
}, qr = /* @__PURE__ */ A({
  ...al,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    bg: String,
    striped: {
      type: Boolean,
      default: !1
    },
    animated: {
      type: Boolean,
      default: !1
    },
    value: {
      type: Number,
      default: 0
    },
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    }
  },
  setup(e) {
    const t = e, a = f(() => [
      "progress-bar",
      t.bg && `bg-${t.bg}`,
      t.striped && "progress-bar-striped",
      t.animated && "progress-bar-animated"
    ]);
    return (l, n) => (d(), V(N(e.tag), {
      class: g(a.value),
      role: "progressbar",
      "aria-valuenow": e.value,
      "aria-valuemin": e.min,
      "aria-valuemax": e.max,
      style: le([
        {
          width: (e.value - e.min) / (e.max - e.min) * 100 + "%"
        }
      ])
    }, {
      default: D(() => [
        O(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "aria-valuenow", "aria-valuemin", "aria-valuemax", "style"]));
  }
}), ll = /* @__PURE__ */ H("span", { class: "visually-hidden" }, "Loading...", -1), nl = {
  name: "MDBSpinner"
}, jr = /* @__PURE__ */ A({
  ...nl,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    grow: {
      type: Boolean,
      default: !1
    },
    color: String,
    size: String
  },
  setup(e) {
    const t = e, a = f(() => [
      t.grow ? "spinner-grow" : "spinner-border",
      t.color && `text-${t.color}`,
      `${t.size ? t.grow ? "spinner-grow-" + t.size : "spinner-border-" + t.size : ""}`
    ]);
    return (l, n) => (d(), V(N(e.tag), {
      class: g(a.value),
      role: "status"
    }, {
      default: D(() => [
        ll,
        O(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), ol = 1e6, xe = (e) => {
  do
    e += Math.floor(Math.random() * ol);
  while (document.getElementById(e));
  return e;
}, rl = /\..*/, sl = {
  mouseenter: "mouseover",
  mouseleave: "mouseout"
}, il = [
  "click",
  "dblclick",
  "mouseup",
  "mousedown",
  "contextmenu",
  "mousewheel",
  "DOMMouseScroll",
  "mouseover",
  "mouseout",
  "mousemove",
  "selectstart",
  "selectend",
  "keydown",
  "keypress",
  "keyup",
  "orientationchange",
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel",
  "pointerdown",
  "pointermove",
  "pointerup",
  "pointerleave",
  "pointercancel",
  "gesturestart",
  "gesturechange",
  "gestureend",
  "focus",
  "blur",
  "change",
  "reset",
  "select",
  "submit",
  "focusin",
  "focusout",
  "load",
  "unload",
  "beforeunload",
  "resize",
  "move",
  "DOMContentLoaded",
  "readystatechange",
  "error",
  "abort",
  "scroll"
];
function Gt(e, t, a) {
  const l = typeof t == "string", n = l ? a : t;
  let o = e.replace(rl, "");
  const r = sl[o];
  return r && (o = r), il.indexOf(o) > -1 || (o = e), [l, n, o];
}
function ul(e, t, a, l) {
  if (typeof t != "string" || !e)
    return;
  a || (a = l, l = void 0);
  const [n, o, r] = Gt(
    t,
    a,
    l
  );
  e.addEventListener(
    r,
    o,
    n
  );
}
function cl(e, t, a, l) {
  e.removeEventListener(
    t,
    a,
    !!l
  );
}
const ne = function(e, t, a, l = void 0) {
  ul(e, t, a, l);
}, ae = function(e, t, a, l = void 0) {
  if (typeof t != "string" || !e)
    return;
  const [n, o, r] = Gt(
    t,
    a,
    l
  );
  cl(
    e,
    r,
    o,
    n ? a : void 0
  );
}, dl = {
  name: "MDBCollapse"
}, fl = /* @__PURE__ */ A({
  ...dl,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    modelValue: Boolean,
    id: String,
    collapseClass: String,
    duration: {
      type: Number,
      default: 300
    },
    sidenav: {
      type: Boolean,
      default: !1
    },
    horizontal: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { expose: t, emit: a }) {
    const l = e, n = p(null), o = p(l.modelValue), r = f(() => [
      s.value,
      l.collapseClass,
      h && h.value ? "navbar-collapse" : "",
      k.value,
      l.horizontal && "collapse-horizontal"
    ]), s = f(() => l.sidenav ? "sidenav-collapse" : o.value ? "collapse" : null), u = Z("accordionState", null), c = Z(
      "incrementAccordionItemsCount",
      !1
    ), i = Z(
      "setAccordionActiveItem",
      !1
    ), m = p(null), $ = () => {
      m.value !== null && o.value && i && i(m.value);
    };
    fe(
      () => {
        u && u.active !== m.value && a("update:modelValue", !1);
      },
      { flush: "post" }
    ), de(() => {
      o.value && n.value && (n.value.style.height = n.value.scrollHeight + "px", n.value.style.width = n.value.scrollWidth + "px"), u && (m.value = c ? c() : 0, o.value && i && i(m.value));
    });
    let v = !1;
    const y = p(0);
    ee(
      () => l.modelValue,
      (x) => {
        if (v) {
          clearInterval(y.value), y.value = setTimeout(() => {
            a("update:modelValue", o.value);
          }, l.duration);
          return;
        }
        o.value = x, u && $();
      }
    ), te("openCollapse", () => {
      a("update:modelValue", !0);
    });
    const h = Z(
      "navbarFlexWrapValue",
      !1
    ), k = f(() => !h || h.value === "wrap" && o.value ? "show" : (h.value === "nowrap" && o.value, !1)), L = (x, _) => {
      _ === "null" && l.modelValue ? o.value = !0 : (_ === "null" && !l.modelValue || _ === "nowrap") && (o.value = !1);
    };
    ee(
      () => h && h.value,
      (x, _) => {
        x === "nowrap" ? o.value = !0 : x === "wrap" && L(x, _), a("update:modelValue", o.value);
      },
      { immediate: !0 }
    );
    const M = f(() => l.id ? l.id : xe("collapsibleContent-")), w = (x) => {
      const _ = x;
      l.horizontal ? _.style.width = "0" : _.style.height = "0", _.style.transitionDuration = l.duration + "ms", v = !0;
    }, T = (x) => {
      var K, B;
      const _ = x;
      l.horizontal ? _.style.width = ((K = n.value) == null ? void 0 : K.scrollWidth) + "px" : _.style.height = ((B = n.value) == null ? void 0 : B.scrollHeight) + "px";
    }, I = (x) => {
      const _ = x;
      _.classList.contains("show") || _.classList.add("show"), l.horizontal ? _.style.width = "" : _.style.height = "", v = !1;
    }, R = (x) => {
      var K, B;
      const _ = x;
      l.horizontal ? _.style.width || (_.classList.add("show"), _.style.width = ((K = n.value) == null ? void 0 : K.scrollWidth) + "px") : _.style.height || (_.classList.add("show"), _.style.height = ((B = n.value) == null ? void 0 : B.scrollHeight) + "px"), v = !0;
    }, W = (x) => {
      const _ = x;
      l.horizontal ? _.style.width = "0px" : _.style.height = "0px";
    }, G = (x) => {
      x.classList.add("collapse"), v = !1;
    }, F = p(null), E = p(!1), P = () => {
      if (!o.value || E.value) return;
      E.value = !0;
      const x = window.innerWidth;
      F.value = x, setTimeout(() => {
        E.value = !1;
      }, 100);
    };
    return de(() => {
      F.value = window.innerWidth, ne(window, "resize", P);
    }), $e(() => {
      ae(window, "resize", P);
    }), t({ collapse: n }), (x, _) => (d(), V(Ne, {
      onBeforeEnter: w,
      onEnter: T,
      onAfterEnter: I,
      onBeforeLeave: R,
      onLeave: W,
      onAfterLeave: G,
      "enter-active-class": "collapsing",
      "leave-active-class": "collapsing show"
    }, {
      default: D(() => [
        ke((d(), V(N(e.tag), {
          class: g(r.value),
          id: M.value,
          ref_key: "collapse",
          ref: n
        }, {
          default: D(() => [
            O(x.$slots, "default")
          ]),
          _: 3
        }, 8, ["class", "id"])), [
          [Wt, o.value]
        ])
      ]),
      _: 3
    }));
  }
});
var oe = "top", ve = "bottom", pe = "right", re = "left", tt = "auto", Ge = [oe, ve, pe, re], Ae = "start", We = "end", vl = "clippingParents", Ut = "viewport", Fe = "popper", pl = "reference", Dt = /* @__PURE__ */ Ge.reduce(function(e, t) {
  return e.concat([t + "-" + Ae, t + "-" + We]);
}, []), Xt = /* @__PURE__ */ [].concat(Ge, [tt]).reduce(function(e, t) {
  return e.concat([t, t + "-" + Ae, t + "-" + We]);
}, []), ml = "beforeRead", gl = "read", hl = "afterRead", yl = "beforeMain", bl = "main", wl = "afterMain", kl = "beforeWrite", Bl = "write", $l = "afterWrite", rt = [ml, gl, hl, yl, bl, wl, kl, Bl, $l];
function Be(e) {
  return e ? (e.nodeName || "").toLowerCase() : null;
}
function ye(e) {
  if (e == null)
    return window;
  if (e.toString() !== "[object Window]") {
    var t = e.ownerDocument;
    return t && t.defaultView || window;
  }
  return e;
}
function Le(e) {
  var t = ye(e).Element;
  return e instanceof t || e instanceof Element;
}
function ce(e) {
  var t = ye(e).HTMLElement;
  return e instanceof t || e instanceof HTMLElement;
}
function ut(e) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = ye(e).ShadowRoot;
  return e instanceof t || e instanceof ShadowRoot;
}
function Sl(e) {
  var t = e.state;
  Object.keys(t.elements).forEach(function(a) {
    var l = t.styles[a] || {}, n = t.attributes[a] || {}, o = t.elements[a];
    !ce(o) || !Be(o) || (Object.assign(o.style, l), Object.keys(n).forEach(function(r) {
      var s = n[r];
      s === !1 ? o.removeAttribute(r) : o.setAttribute(r, s === !0 ? "" : s);
    }));
  });
}
function xl(e) {
  var t = e.state, a = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, a.popper), t.styles = a, t.elements.arrow && Object.assign(t.elements.arrow.style, a.arrow), function() {
    Object.keys(t.elements).forEach(function(l) {
      var n = t.elements[l], o = t.attributes[l] || {}, r = Object.keys(t.styles.hasOwnProperty(l) ? t.styles[l] : a[l]), s = r.reduce(function(u, c) {
        return u[c] = "", u;
      }, {});
      !ce(n) || !Be(n) || (Object.assign(n.style, s), Object.keys(o).forEach(function(u) {
        n.removeAttribute(u);
      }));
    });
  };
}
const Cl = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: Sl,
  effect: xl,
  requires: ["computeStyles"]
};
function me(e) {
  return e.split("-")[0];
}
var Ee = Math.max, Je = Math.min, _e = Math.round;
function Ie(e, t) {
  t === void 0 && (t = !1);
  var a = e.getBoundingClientRect(), l = 1, n = 1;
  if (ce(e) && t) {
    var o = e.offsetHeight, r = e.offsetWidth;
    r > 0 && (l = _e(a.width) / r || 1), o > 0 && (n = _e(a.height) / o || 1);
  }
  return {
    width: a.width / l,
    height: a.height / n,
    top: a.top / n,
    right: a.right / l,
    bottom: a.bottom / n,
    left: a.left / l,
    x: a.left / l,
    y: a.top / n
  };
}
function ct(e) {
  var t = Ie(e), a = e.offsetWidth, l = e.offsetHeight;
  return Math.abs(t.width - a) <= 1 && (a = t.width), Math.abs(t.height - l) <= 1 && (l = t.height), {
    x: e.offsetLeft,
    y: e.offsetTop,
    width: a,
    height: l
  };
}
function Yt(e, t) {
  var a = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (a && ut(a)) {
    var l = t;
    do {
      if (l && e.isSameNode(l))
        return !0;
      l = l.parentNode || l.host;
    } while (l);
  }
  return !1;
}
function he(e) {
  return ye(e).getComputedStyle(e);
}
function Ml(e) {
  return ["table", "td", "th"].indexOf(Be(e)) >= 0;
}
function Ce(e) {
  return ((Le(e) ? e.ownerDocument : (
    // $FlowFixMe[prop-missing]
    e.document
  )) || window.document).documentElement;
}
function at(e) {
  return Be(e) === "html" ? e : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    e.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    e.parentNode || // DOM Element detected
    (ut(e) ? e.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    Ce(e)
  );
}
function Ot(e) {
  return !ce(e) || // https://github.com/popperjs/popper-core/issues/837
  he(e).position === "fixed" ? null : e.offsetParent;
}
function Vl(e) {
  var t = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, a = navigator.userAgent.indexOf("Trident") !== -1;
  if (a && ce(e)) {
    var l = he(e);
    if (l.position === "fixed")
      return null;
  }
  var n = at(e);
  for (ut(n) && (n = n.host); ce(n) && ["html", "body"].indexOf(Be(n)) < 0; ) {
    var o = he(n);
    if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || t && o.willChange === "filter" || t && o.filter && o.filter !== "none")
      return n;
    n = n.parentNode;
  }
  return null;
}
function Ue(e) {
  for (var t = ye(e), a = Ot(e); a && Ml(a) && he(a).position === "static"; )
    a = Ot(a);
  return a && (Be(a) === "html" || Be(a) === "body" && he(a).position === "static") ? t : a || Vl(e) || t;
}
function dt(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
}
function Re(e, t, a) {
  return Ee(e, Je(t, a));
}
function Dl(e, t, a) {
  var l = Re(e, t, a);
  return l > a ? a : l;
}
function Kt() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function Jt(e) {
  return Object.assign({}, Kt(), e);
}
function Qt(e, t) {
  return t.reduce(function(a, l) {
    return a[l] = e, a;
  }, {});
}
var Ol = function(t, a) {
  return t = typeof t == "function" ? t(Object.assign({}, a.rects, {
    placement: a.placement
  })) : t, Jt(typeof t != "number" ? t : Qt(t, Ge));
};
function El(e) {
  var t, a = e.state, l = e.name, n = e.options, o = a.elements.arrow, r = a.modifiersData.popperOffsets, s = me(a.placement), u = dt(s), c = [re, pe].indexOf(s) >= 0, i = c ? "height" : "width";
  if (!(!o || !r)) {
    var m = Ol(n.padding, a), $ = ct(o), v = u === "y" ? oe : re, y = u === "y" ? ve : pe, S = a.rects.reference[i] + a.rects.reference[u] - r[u] - a.rects.popper[i], h = r[u] - a.rects.reference[u], k = Ue(o), L = k ? u === "y" ? k.clientHeight || 0 : k.clientWidth || 0 : 0, M = S / 2 - h / 2, w = m[v], T = L - $[i] - m[y], I = L / 2 - $[i] / 2 + M, R = Re(w, I, T), W = u;
    a.modifiersData[l] = (t = {}, t[W] = R, t.centerOffset = R - I, t);
  }
}
function Nl(e) {
  var t = e.state, a = e.options, l = a.element, n = l === void 0 ? "[data-popper-arrow]" : l;
  if (n != null && !(typeof n == "string" && (n = t.elements.popper.querySelector(n), !n))) {
    if (process.env.NODE_ENV !== "production" && (ce(n) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "))), !Yt(t.elements.popper, n)) {
      process.env.NODE_ENV !== "production" && console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      return;
    }
    t.elements.arrow = n;
  }
}
const Tl = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: El,
  effect: Nl,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Pe(e) {
  return e.split("-")[1];
}
var Al = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function Ll(e) {
  var t = e.x, a = e.y, l = window, n = l.devicePixelRatio || 1;
  return {
    x: _e(t * n) / n || 0,
    y: _e(a * n) / n || 0
  };
}
function Et(e) {
  var t, a = e.popper, l = e.popperRect, n = e.placement, o = e.variation, r = e.offsets, s = e.position, u = e.gpuAcceleration, c = e.adaptive, i = e.roundOffsets, m = e.isFixed, $ = r.x, v = $ === void 0 ? 0 : $, y = r.y, S = y === void 0 ? 0 : y, h = typeof i == "function" ? i({
    x: v,
    y: S
  }) : {
    x: v,
    y: S
  };
  v = h.x, S = h.y;
  var k = r.hasOwnProperty("x"), L = r.hasOwnProperty("y"), M = re, w = oe, T = window;
  if (c) {
    var I = Ue(a), R = "clientHeight", W = "clientWidth";
    if (I === ye(a) && (I = Ce(a), he(I).position !== "static" && s === "absolute" && (R = "scrollHeight", W = "scrollWidth")), I = I, n === oe || (n === re || n === pe) && o === We) {
      w = ve;
      var G = m && I === T && T.visualViewport ? T.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        I[R]
      );
      S -= G - l.height, S *= u ? 1 : -1;
    }
    if (n === re || (n === oe || n === ve) && o === We) {
      M = pe;
      var F = m && I === T && T.visualViewport ? T.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        I[W]
      );
      v -= F - l.width, v *= u ? 1 : -1;
    }
  }
  var E = Object.assign({
    position: s
  }, c && Al), P = i === !0 ? Ll({
    x: v,
    y: S
  }) : {
    x: v,
    y: S
  };
  if (v = P.x, S = P.y, u) {
    var x;
    return Object.assign({}, E, (x = {}, x[w] = L ? "0" : "", x[M] = k ? "0" : "", x.transform = (T.devicePixelRatio || 1) <= 1 ? "translate(" + v + "px, " + S + "px)" : "translate3d(" + v + "px, " + S + "px, 0)", x));
  }
  return Object.assign({}, E, (t = {}, t[w] = L ? S + "px" : "", t[M] = k ? v + "px" : "", t.transform = "", t));
}
function _l(e) {
  var t = e.state, a = e.options, l = a.gpuAcceleration, n = l === void 0 ? !0 : l, o = a.adaptive, r = o === void 0 ? !0 : o, s = a.roundOffsets, u = s === void 0 ? !0 : s;
  if (process.env.NODE_ENV !== "production") {
    var c = he(t.elements.popper).transitionProperty || "";
    r && ["transform", "top", "right", "bottom", "left"].some(function(m) {
      return c.indexOf(m) >= 0;
    }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
  }
  var i = {
    placement: me(t.placement),
    variation: Pe(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: n,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Et(Object.assign({}, i, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: r,
    roundOffsets: u
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Et(Object.assign({}, i, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: u
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const Il = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: _l,
  data: {}
};
var Ye = {
  passive: !0
};
function Pl(e) {
  var t = e.state, a = e.instance, l = e.options, n = l.scroll, o = n === void 0 ? !0 : n, r = l.resize, s = r === void 0 ? !0 : r, u = ye(t.elements.popper), c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return o && c.forEach(function(i) {
    i.addEventListener("scroll", a.update, Ye);
  }), s && u.addEventListener("resize", a.update, Ye), function() {
    o && c.forEach(function(i) {
      i.removeEventListener("scroll", a.update, Ye);
    }), s && u.removeEventListener("resize", a.update, Ye);
  };
}
const Fl = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: Pl,
  data: {}
};
var Rl = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function Ke(e) {
  return e.replace(/left|right|bottom|top/g, function(t) {
    return Rl[t];
  });
}
var ql = {
  start: "end",
  end: "start"
};
function Nt(e) {
  return e.replace(/start|end/g, function(t) {
    return ql[t];
  });
}
function ft(e) {
  var t = ye(e), a = t.pageXOffset, l = t.pageYOffset;
  return {
    scrollLeft: a,
    scrollTop: l
  };
}
function vt(e) {
  return Ie(Ce(e)).left + ft(e).scrollLeft;
}
function jl(e) {
  var t = ye(e), a = Ce(e), l = t.visualViewport, n = a.clientWidth, o = a.clientHeight, r = 0, s = 0;
  return l && (n = l.width, o = l.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (r = l.offsetLeft, s = l.offsetTop)), {
    width: n,
    height: o,
    x: r + vt(e),
    y: s
  };
}
function zl(e) {
  var t, a = Ce(e), l = ft(e), n = (t = e.ownerDocument) == null ? void 0 : t.body, o = Ee(a.scrollWidth, a.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), r = Ee(a.scrollHeight, a.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), s = -l.scrollLeft + vt(e), u = -l.scrollTop;
  return he(n || a).direction === "rtl" && (s += Ee(a.clientWidth, n ? n.clientWidth : 0) - o), {
    width: o,
    height: r,
    x: s,
    y: u
  };
}
function pt(e) {
  var t = he(e), a = t.overflow, l = t.overflowX, n = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(a + n + l);
}
function Zt(e) {
  return ["html", "body", "#document"].indexOf(Be(e)) >= 0 ? e.ownerDocument.body : ce(e) && pt(e) ? e : Zt(at(e));
}
function qe(e, t) {
  var a;
  t === void 0 && (t = []);
  var l = Zt(e), n = l === ((a = e.ownerDocument) == null ? void 0 : a.body), o = ye(l), r = n ? [o].concat(o.visualViewport || [], pt(l) ? l : []) : l, s = t.concat(r);
  return n ? s : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    s.concat(qe(at(r)))
  );
}
function st(e) {
  return Object.assign({}, e, {
    left: e.x,
    top: e.y,
    right: e.x + e.width,
    bottom: e.y + e.height
  });
}
function Wl(e) {
  var t = Ie(e);
  return t.top = t.top + e.clientTop, t.left = t.left + e.clientLeft, t.bottom = t.top + e.clientHeight, t.right = t.left + e.clientWidth, t.width = e.clientWidth, t.height = e.clientHeight, t.x = t.left, t.y = t.top, t;
}
function Tt(e, t) {
  return t === Ut ? st(jl(e)) : Le(t) ? Wl(t) : st(zl(Ce(e)));
}
function Hl(e) {
  var t = qe(at(e)), a = ["absolute", "fixed"].indexOf(he(e).position) >= 0, l = a && ce(e) ? Ue(e) : e;
  return Le(l) ? t.filter(function(n) {
    return Le(n) && Yt(n, l) && Be(n) !== "body";
  }) : [];
}
function Gl(e, t, a) {
  var l = t === "clippingParents" ? Hl(e) : [].concat(t), n = [].concat(l, [a]), o = n[0], r = n.reduce(function(s, u) {
    var c = Tt(e, u);
    return s.top = Ee(c.top, s.top), s.right = Je(c.right, s.right), s.bottom = Je(c.bottom, s.bottom), s.left = Ee(c.left, s.left), s;
  }, Tt(e, o));
  return r.width = r.right - r.left, r.height = r.bottom - r.top, r.x = r.left, r.y = r.top, r;
}
function ea(e) {
  var t = e.reference, a = e.element, l = e.placement, n = l ? me(l) : null, o = l ? Pe(l) : null, r = t.x + t.width / 2 - a.width / 2, s = t.y + t.height / 2 - a.height / 2, u;
  switch (n) {
    case oe:
      u = {
        x: r,
        y: t.y - a.height
      };
      break;
    case ve:
      u = {
        x: r,
        y: t.y + t.height
      };
      break;
    case pe:
      u = {
        x: t.x + t.width,
        y: s
      };
      break;
    case re:
      u = {
        x: t.x - a.width,
        y: s
      };
      break;
    default:
      u = {
        x: t.x,
        y: t.y
      };
  }
  var c = n ? dt(n) : null;
  if (c != null) {
    var i = c === "y" ? "height" : "width";
    switch (o) {
      case Ae:
        u[c] = u[c] - (t[i] / 2 - a[i] / 2);
        break;
      case We:
        u[c] = u[c] + (t[i] / 2 - a[i] / 2);
        break;
    }
  }
  return u;
}
function He(e, t) {
  t === void 0 && (t = {});
  var a = t, l = a.placement, n = l === void 0 ? e.placement : l, o = a.boundary, r = o === void 0 ? vl : o, s = a.rootBoundary, u = s === void 0 ? Ut : s, c = a.elementContext, i = c === void 0 ? Fe : c, m = a.altBoundary, $ = m === void 0 ? !1 : m, v = a.padding, y = v === void 0 ? 0 : v, S = Jt(typeof y != "number" ? y : Qt(y, Ge)), h = i === Fe ? pl : Fe, k = e.rects.popper, L = e.elements[$ ? h : i], M = Gl(Le(L) ? L : L.contextElement || Ce(e.elements.popper), r, u), w = Ie(e.elements.reference), T = ea({
    reference: w,
    element: k,
    strategy: "absolute",
    placement: n
  }), I = st(Object.assign({}, k, T)), R = i === Fe ? I : w, W = {
    top: M.top - R.top + S.top,
    bottom: R.bottom - M.bottom + S.bottom,
    left: M.left - R.left + S.left,
    right: R.right - M.right + S.right
  }, G = e.modifiersData.offset;
  if (i === Fe && G) {
    var F = G[n];
    Object.keys(W).forEach(function(E) {
      var P = [pe, ve].indexOf(E) >= 0 ? 1 : -1, x = [oe, ve].indexOf(E) >= 0 ? "y" : "x";
      W[E] += F[x] * P;
    });
  }
  return W;
}
function Ul(e, t) {
  t === void 0 && (t = {});
  var a = t, l = a.placement, n = a.boundary, o = a.rootBoundary, r = a.padding, s = a.flipVariations, u = a.allowedAutoPlacements, c = u === void 0 ? Xt : u, i = Pe(l), m = i ? s ? Dt : Dt.filter(function(y) {
    return Pe(y) === i;
  }) : Ge, $ = m.filter(function(y) {
    return c.indexOf(y) >= 0;
  });
  $.length === 0 && ($ = m, process.env.NODE_ENV !== "production" && console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" ")));
  var v = $.reduce(function(y, S) {
    return y[S] = He(e, {
      placement: S,
      boundary: n,
      rootBoundary: o,
      padding: r
    })[me(S)], y;
  }, {});
  return Object.keys(v).sort(function(y, S) {
    return v[y] - v[S];
  });
}
function Xl(e) {
  if (me(e) === tt)
    return [];
  var t = Ke(e);
  return [Nt(e), t, Nt(t)];
}
function Yl(e) {
  var t = e.state, a = e.options, l = e.name;
  if (!t.modifiersData[l]._skip) {
    for (var n = a.mainAxis, o = n === void 0 ? !0 : n, r = a.altAxis, s = r === void 0 ? !0 : r, u = a.fallbackPlacements, c = a.padding, i = a.boundary, m = a.rootBoundary, $ = a.altBoundary, v = a.flipVariations, y = v === void 0 ? !0 : v, S = a.allowedAutoPlacements, h = t.options.placement, k = me(h), L = k === h, M = u || (L || !y ? [Ke(h)] : Xl(h)), w = [h].concat(M).reduce(function(be, we) {
      return be.concat(me(we) === tt ? Ul(t, {
        placement: we,
        boundary: i,
        rootBoundary: m,
        padding: c,
        flipVariations: y,
        allowedAutoPlacements: S
      }) : we);
    }, []), T = t.rects.reference, I = t.rects.popper, R = /* @__PURE__ */ new Map(), W = !0, G = w[0], F = 0; F < w.length; F++) {
      var E = w[F], P = me(E), x = Pe(E) === Ae, _ = [oe, ve].indexOf(P) >= 0, K = _ ? "width" : "height", B = He(t, {
        placement: E,
        boundary: i,
        rootBoundary: m,
        altBoundary: $,
        padding: c
      }), j = _ ? x ? pe : re : x ? ve : oe;
      T[K] > I[K] && (j = Ke(j));
      var X = Ke(j), Y = [];
      if (o && Y.push(B[P] <= 0), s && Y.push(B[j] <= 0, B[X] <= 0), Y.every(function(be) {
        return be;
      })) {
        G = E, W = !1;
        break;
      }
      R.set(E, Y);
    }
    if (W)
      for (var se = y ? 3 : 1, ie = function(we) {
        var U = w.find(function(J) {
          var Me = R.get(J);
          if (Me)
            return Me.slice(0, we).every(function(lt) {
              return lt;
            });
        });
        if (U)
          return G = U, "break";
      }, ue = se; ue > 0; ue--) {
        var Te = ie(ue);
        if (Te === "break") break;
      }
    t.placement !== G && (t.modifiersData[l]._skip = !0, t.placement = G, t.reset = !0);
  }
}
const Kl = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: Yl,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function At(e, t, a) {
  return a === void 0 && (a = {
    x: 0,
    y: 0
  }), {
    top: e.top - t.height - a.y,
    right: e.right - t.width + a.x,
    bottom: e.bottom - t.height + a.y,
    left: e.left - t.width - a.x
  };
}
function Lt(e) {
  return [oe, pe, ve, re].some(function(t) {
    return e[t] >= 0;
  });
}
function Jl(e) {
  var t = e.state, a = e.name, l = t.rects.reference, n = t.rects.popper, o = t.modifiersData.preventOverflow, r = He(t, {
    elementContext: "reference"
  }), s = He(t, {
    altBoundary: !0
  }), u = At(r, l), c = At(s, n, o), i = Lt(u), m = Lt(c);
  t.modifiersData[a] = {
    referenceClippingOffsets: u,
    popperEscapeOffsets: c,
    isReferenceHidden: i,
    hasPopperEscaped: m
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": i,
    "data-popper-escaped": m
  });
}
const Ql = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: Jl
};
function Zl(e, t, a) {
  var l = me(e), n = [re, oe].indexOf(l) >= 0 ? -1 : 1, o = typeof a == "function" ? a(Object.assign({}, t, {
    placement: e
  })) : a, r = o[0], s = o[1];
  return r = r || 0, s = (s || 0) * n, [re, pe].indexOf(l) >= 0 ? {
    x: s,
    y: r
  } : {
    x: r,
    y: s
  };
}
function en(e) {
  var t = e.state, a = e.options, l = e.name, n = a.offset, o = n === void 0 ? [0, 0] : n, r = Xt.reduce(function(i, m) {
    return i[m] = Zl(m, t.rects, o), i;
  }, {}), s = r[t.placement], u = s.x, c = s.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += u, t.modifiersData.popperOffsets.y += c), t.modifiersData[l] = r;
}
const tn = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: en
};
function an(e) {
  var t = e.state, a = e.name;
  t.modifiersData[a] = ea({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
const ln = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: an,
  data: {}
};
function nn(e) {
  return e === "x" ? "y" : "x";
}
function on(e) {
  var t = e.state, a = e.options, l = e.name, n = a.mainAxis, o = n === void 0 ? !0 : n, r = a.altAxis, s = r === void 0 ? !1 : r, u = a.boundary, c = a.rootBoundary, i = a.altBoundary, m = a.padding, $ = a.tether, v = $ === void 0 ? !0 : $, y = a.tetherOffset, S = y === void 0 ? 0 : y, h = He(t, {
    boundary: u,
    rootBoundary: c,
    padding: m,
    altBoundary: i
  }), k = me(t.placement), L = Pe(t.placement), M = !L, w = dt(k), T = nn(w), I = t.modifiersData.popperOffsets, R = t.rects.reference, W = t.rects.popper, G = typeof S == "function" ? S(Object.assign({}, t.rects, {
    placement: t.placement
  })) : S, F = typeof G == "number" ? {
    mainAxis: G,
    altAxis: G
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, G), E = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, P = {
    x: 0,
    y: 0
  };
  if (I) {
    if (o) {
      var x, _ = w === "y" ? oe : re, K = w === "y" ? ve : pe, B = w === "y" ? "height" : "width", j = I[w], X = j + h[_], Y = j - h[K], se = v ? -W[B] / 2 : 0, ie = L === Ae ? R[B] : W[B], ue = L === Ae ? -W[B] : -R[B], Te = t.elements.arrow, be = v && Te ? ct(Te) : {
        width: 0,
        height: 0
      }, we = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : Kt(), U = we[_], J = we[K], Me = Re(0, R[B], be[B]), lt = M ? R[B] / 2 - se - Me - U - F.mainAxis : ie - Me - U - F.mainAxis, aa = M ? -R[B] / 2 + se + Me + J + F.mainAxis : ue + Me + J + F.mainAxis, nt = t.elements.arrow && Ue(t.elements.arrow), la = nt ? w === "y" ? nt.clientTop || 0 : nt.clientLeft || 0 : 0, gt = (x = E == null ? void 0 : E[w]) != null ? x : 0, na = j + lt - gt - la, oa = j + aa - gt, ht = Re(v ? Je(X, na) : X, j, v ? Ee(Y, oa) : Y);
      I[w] = ht, P[w] = ht - j;
    }
    if (s) {
      var yt, ra = w === "x" ? oe : re, sa = w === "x" ? ve : pe, Ve = I[T], Xe = T === "y" ? "height" : "width", bt = Ve + h[ra], wt = Ve - h[sa], ot = [oe, re].indexOf(k) !== -1, kt = (yt = E == null ? void 0 : E[T]) != null ? yt : 0, Bt = ot ? bt : Ve - R[Xe] - W[Xe] - kt + F.altAxis, $t = ot ? Ve + R[Xe] + W[Xe] - kt - F.altAxis : wt, St = v && ot ? Dl(Bt, Ve, $t) : Re(v ? Bt : bt, Ve, v ? $t : wt);
      I[T] = St, P[T] = St - Ve;
    }
    t.modifiersData[l] = P;
  }
}
const rn = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: on,
  requiresIfExists: ["offset"]
};
function sn(e) {
  return {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  };
}
function un(e) {
  return e === ye(e) || !ce(e) ? ft(e) : sn(e);
}
function cn(e) {
  var t = e.getBoundingClientRect(), a = _e(t.width) / e.offsetWidth || 1, l = _e(t.height) / e.offsetHeight || 1;
  return a !== 1 || l !== 1;
}
function dn(e, t, a) {
  a === void 0 && (a = !1);
  var l = ce(t), n = ce(t) && cn(t), o = Ce(t), r = Ie(e, n), s = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = {
    x: 0,
    y: 0
  };
  return (l || !l && !a) && ((Be(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  pt(o)) && (s = un(t)), ce(t) ? (u = Ie(t, !0), u.x += t.clientLeft, u.y += t.clientTop) : o && (u.x = vt(o))), {
    x: r.left + s.scrollLeft - u.x,
    y: r.top + s.scrollTop - u.y,
    width: r.width,
    height: r.height
  };
}
function fn(e) {
  var t = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Set(), l = [];
  e.forEach(function(o) {
    t.set(o.name, o);
  });
  function n(o) {
    a.add(o.name);
    var r = [].concat(o.requires || [], o.requiresIfExists || []);
    r.forEach(function(s) {
      if (!a.has(s)) {
        var u = t.get(s);
        u && n(u);
      }
    }), l.push(o);
  }
  return e.forEach(function(o) {
    a.has(o.name) || n(o);
  }), l;
}
function vn(e) {
  var t = fn(e);
  return rt.reduce(function(a, l) {
    return a.concat(t.filter(function(n) {
      return n.phase === l;
    }));
  }, []);
}
function pn(e) {
  var t;
  return function() {
    return t || (t = new Promise(function(a) {
      Promise.resolve().then(function() {
        t = void 0, a(e());
      });
    })), t;
  };
}
function Se(e) {
  for (var t = arguments.length, a = new Array(t > 1 ? t - 1 : 0), l = 1; l < t; l++)
    a[l - 1] = arguments[l];
  return [].concat(a).reduce(function(n, o) {
    return n.replace(/%s/, o);
  }, e);
}
var De = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s', mn = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available', _t = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function gn(e) {
  e.forEach(function(t) {
    [].concat(Object.keys(t), _t).filter(function(a, l, n) {
      return n.indexOf(a) === l;
    }).forEach(function(a) {
      switch (a) {
        case "name":
          typeof t.name != "string" && console.error(Se(De, String(t.name), '"name"', '"string"', '"' + String(t.name) + '"'));
          break;
        case "enabled":
          typeof t.enabled != "boolean" && console.error(Se(De, t.name, '"enabled"', '"boolean"', '"' + String(t.enabled) + '"'));
          break;
        case "phase":
          rt.indexOf(t.phase) < 0 && console.error(Se(De, t.name, '"phase"', "either " + rt.join(", "), '"' + String(t.phase) + '"'));
          break;
        case "fn":
          typeof t.fn != "function" && console.error(Se(De, t.name, '"fn"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "effect":
          t.effect != null && typeof t.effect != "function" && console.error(Se(De, t.name, '"effect"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "requires":
          t.requires != null && !Array.isArray(t.requires) && console.error(Se(De, t.name, '"requires"', '"array"', '"' + String(t.requires) + '"'));
          break;
        case "requiresIfExists":
          Array.isArray(t.requiresIfExists) || console.error(Se(De, t.name, '"requiresIfExists"', '"array"', '"' + String(t.requiresIfExists) + '"'));
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + t.name + '" modifier, valid properties are ' + _t.map(function(l) {
            return '"' + l + '"';
          }).join(", ") + '; but "' + a + '" was provided.');
      }
      t.requires && t.requires.forEach(function(l) {
        e.find(function(n) {
          return n.name === l;
        }) == null && console.error(Se(mn, String(t.name), l, l));
      });
    });
  });
}
function hn(e, t) {
  var a = /* @__PURE__ */ new Set();
  return e.filter(function(l) {
    var n = t(l);
    if (!a.has(n))
      return a.add(n), !0;
  });
}
function yn(e) {
  var t = e.reduce(function(a, l) {
    var n = a[l.name];
    return a[l.name] = n ? Object.assign({}, n, l, {
      options: Object.assign({}, n.options, l.options),
      data: Object.assign({}, n.data, l.data)
    }) : l, a;
  }, {});
  return Object.keys(t).map(function(a) {
    return t[a];
  });
}
var It = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.", bn = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.", Pt = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function Ft() {
  for (var e = arguments.length, t = new Array(e), a = 0; a < e; a++)
    t[a] = arguments[a];
  return !t.some(function(l) {
    return !(l && typeof l.getBoundingClientRect == "function");
  });
}
function wn(e) {
  e === void 0 && (e = {});
  var t = e, a = t.defaultModifiers, l = a === void 0 ? [] : a, n = t.defaultOptions, o = n === void 0 ? Pt : n;
  return function(s, u, c) {
    c === void 0 && (c = o);
    var i = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, Pt, o),
      modifiersData: {},
      elements: {
        reference: s,
        popper: u
      },
      attributes: {},
      styles: {}
    }, m = [], $ = !1, v = {
      state: i,
      setOptions: function(k) {
        var L = typeof k == "function" ? k(i.options) : k;
        S(), i.options = Object.assign({}, o, i.options, L), i.scrollParents = {
          reference: Le(s) ? qe(s) : s.contextElement ? qe(s.contextElement) : [],
          popper: qe(u)
        };
        var M = vn(yn([].concat(l, i.options.modifiers)));
        if (i.orderedModifiers = M.filter(function(E) {
          return E.enabled;
        }), process.env.NODE_ENV !== "production") {
          var w = hn([].concat(M, i.options.modifiers), function(E) {
            var P = E.name;
            return P;
          });
          if (gn(w), me(i.options.placement) === tt) {
            var T = i.orderedModifiers.find(function(E) {
              var P = E.name;
              return P === "flip";
            });
            T || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
          }
          var I = he(u), R = I.marginTop, W = I.marginRight, G = I.marginBottom, F = I.marginLeft;
          [R, W, G, F].some(function(E) {
            return parseFloat(E);
          }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
        }
        return y(), v.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!$) {
          var k = i.elements, L = k.reference, M = k.popper;
          if (!Ft(L, M)) {
            process.env.NODE_ENV !== "production" && console.error(It);
            return;
          }
          i.rects = {
            reference: dn(L, Ue(M), i.options.strategy === "fixed"),
            popper: ct(M)
          }, i.reset = !1, i.placement = i.options.placement, i.orderedModifiers.forEach(function(E) {
            return i.modifiersData[E.name] = Object.assign({}, E.data);
          });
          for (var w = 0, T = 0; T < i.orderedModifiers.length; T++) {
            if (process.env.NODE_ENV !== "production" && (w += 1, w > 100)) {
              console.error(bn);
              break;
            }
            if (i.reset === !0) {
              i.reset = !1, T = -1;
              continue;
            }
            var I = i.orderedModifiers[T], R = I.fn, W = I.options, G = W === void 0 ? {} : W, F = I.name;
            typeof R == "function" && (i = R({
              state: i,
              options: G,
              name: F,
              instance: v
            }) || i);
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: pn(function() {
        return new Promise(function(h) {
          v.forceUpdate(), h(i);
        });
      }),
      destroy: function() {
        S(), $ = !0;
      }
    };
    if (!Ft(s, u))
      return process.env.NODE_ENV !== "production" && console.error(It), v;
    v.setOptions(c).then(function(h) {
      !$ && c.onFirstUpdate && c.onFirstUpdate(h);
    });
    function y() {
      i.orderedModifiers.forEach(function(h) {
        var k = h.name, L = h.options, M = L === void 0 ? {} : L, w = h.effect;
        if (typeof w == "function") {
          var T = w({
            state: i,
            name: k,
            instance: v,
            options: M
          }), I = function() {
          };
          m.push(T || I);
        }
      });
    }
    function S() {
      m.forEach(function(h) {
        return h();
      }), m = [];
    }
    return v;
  };
}
var kn = [Fl, ln, Il, Cl, tn, Kl, rn, Tl, Ql], Rt = /* @__PURE__ */ wn({
  defaultModifiers: kn
});
function mt() {
  const e = p(!1), t = p(), a = p(), l = p(void 0), n = ia({});
  function o(v, y, S) {
    t.value = v, a.value = y, n.value = {
      placement: "bottom",
      modifiers: [
        {
          name: "offset",
          options: {
            offset: [0, 0]
          }
        }
      ],
      ...S
    };
  }
  function r() {
    e.value = !e.value, e.value && je(() => c());
  }
  function s() {
    e.value || (e.value = !0, je(() => l.value = c()));
  }
  function u() {
    e.value && (e.value = !e.value);
  }
  function c() {
    !t.value || !a.value || (l.value === void 0 || !l.value ? l.value = Rt(
      t.value,
      a.value,
      n.value
    ) : l.value.update());
  }
  function i(v, y) {
    n.value && (n.value[v] = y), t.value && a.value && (l.value = Rt(
      t.value,
      a.value,
      n.value
    ));
  }
  function m() {
    l.value && (l.value.destroy(), l.value = void 0);
  }
  function $(v, y) {
    return typeof v == "string" ? v.split(",").map((S) => Number.parseInt(S, 10)) : typeof v == "function" ? (S) => v(S, y) : v;
  }
  return {
    setPopper: o,
    togglePopper: r,
    isPopperActive: e,
    openPopper: s,
    closePopper: u,
    updatePopper: i,
    destroyPopper: m,
    getPopperOffset: $
  };
}
const ta = (e, t) => {
  const a = {
    none: {
      width: 0,
      attr: null
    },
    sm: {
      width: 576,
      attr: null
    },
    md: {
      width: 768,
      attr: null
    },
    lg: {
      width: 992,
      attr: null
    },
    xl: {
      width: 1200,
      attr: null
    },
    xxl: {
      width: 1400,
      attr: null
    },
    mega: {
      width: 1e4,
      attr: null
    }
  };
  t.forEach((o) => {
    const r = Object.keys(a).filter(
      (s) => o.includes(s) ? s : !1
    )[0];
    r ? a[r].attr = o : a.none.attr = o;
  });
  const l = {};
  return Object.keys(a).reduce((o, r, s) => a[o].attr && a[r].attr || a[o].attr && !r ? (l[a[o].attr] = {
    min: a[o].width,
    max: a[r].width
  }, r) : a[o].attr && !a[r].attr ? (s === Object.keys(a).length - 1 && (l[a[o].attr] = {
    min: a[o].width,
    max: a[r].width
  }), o) : ""), Object.keys(l).filter((o) => {
    if (e > l[o].min && e < l[o].max)
      return o;
  })[0];
}, Qe = () => typeof window < "u" && window.matchMedia ? window.matchMedia("(prefers-reduced-motion: reduce)").matches : !1, Bn = {
  name: "MDBDropdown"
}, zr = /* @__PURE__ */ A({
  ...Bn,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    boundary: {
      type: String,
      default: "clippingParent"
    },
    btnGroup: {
      type: Boolean,
      default: !1
    },
    dropup: {
      type: Boolean,
      default: !1
    },
    dropend: {
      type: Boolean,
      default: !1
    },
    dropstart: {
      type: Boolean,
      default: !1
    },
    align: {
      type: [String, Array],
      default: "start"
    },
    offset: {
      type: [Array, String, Function],
      default: () => [0, 0]
    },
    popperConfig: [null, Object, Function],
    target: String,
    modelValue: Boolean
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = f(() => [
      a.btnGroup ? "btn-group" : "dropdown",
      a.dropup && "dropup",
      a.dropend && "dropend",
      a.dropstart && "dropstart"
    ]), {
      setPopper: n,
      isPopperActive: o,
      closePopper: r,
      openPopper: s,
      updatePopper: u,
      getPopperOffset: c
    } = mt(), i = p(null), m = p(null), $ = p(null), v = p(window.innerWidth), y = p("");
    te("menuAlignClasses", y), te("closePopper", r);
    const S = p(a.modelValue), h = p(!0), k = p(0), L = p(0);
    ee(
      () => a.modelValue,
      (x) => {
        clearInterval(L.value), h.value && x !== S.value && (S.value = a.modelValue, h.value = !1), L.value = setTimeout(
          () => {
            S.value = a.modelValue;
          },
          Qe() ? 0 : 300
        );
      }
    ), ee(
      () => h.value,
      (x) => {
        x || (k.value = setTimeout(
          () => {
            h.value = !0;
          },
          Qe() ? 0 : 200
        ));
      }
    ), te("isActive", S);
    const M = p(!1), w = p(null);
    te("setMenuMountedState", (x, _) => {
      M.value = x, w.value = _;
    });
    const I = (x) => {
      x ? (F(), s()) : r();
    };
    ee(
      () => M.value,
      (x) => I(x),
      { immediate: !0 }
    ), te("isPopperActive", o), te("externalTarget", a.target), te("handleEscAndOutsideClick", () => {
      t("update:modelValue", !1);
    });
    const W = a.dropup ? "top" : a.dropend ? "right" : a.dropstart ? "left" : "bottom", G = () => {
      typeof a.align == "string" ? y.value = `dropdown-menu-${a.align}` : y.value = a.align.map(
        (j) => `dropdown-menu-${j}`.trim()
      );
      let x = a.align;
      (typeof a.align != "string" || a.align !== "start" && a.align !== "end") && (x = E(), ne(window, "resize", P));
      const _ = `${W}-${x}`;
      let K = document.querySelector(a.boundary);
      K || (K = a.boundary);
      const B = {
        placement: _,
        modifiers: [
          {
            name: "preventOverflow",
            options: {
              boundary: K
            }
          },
          {
            name: "offset",
            options: {
              offset: c(a.offset, i.value)
            }
          }
        ]
      };
      return {
        ...B,
        ...typeof a.popperConfig == "function" ? a.popperConfig(B) : a.popperConfig
      };
    }, F = () => {
      var _;
      m.value = a.target ? document.querySelector(a.target) : (_ = i.value) == null ? void 0 : _.querySelector("[data-trigger]"), $.value = w.value;
      const x = G();
      n(m.value, $.value, x);
    }, E = () => {
      v.value = window.innerWidth;
      let x = a.align;
      typeof a.align == "string" && (x = ["start", a.align]);
      const _ = ta(
        v.value,
        x
      );
      return _ ? _.includes("start") ? "start" : "end" : "";
    }, P = () => {
      const x = E();
      u("placement", `${W}-${x}`);
    };
    return $e(() => {
      clearInterval(k.value), clearInterval(L.value), ae(window, "resize", P);
    }), (x, _) => (d(), V(N(e.tag), {
      class: g(l.value),
      ref_key: "root",
      ref: i
    }, {
      default: D(() => [
        O(x.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Ze = {
  stopProp(e) {
    e.stopPropagation();
  },
  mounted(e, t) {
    const a = (n) => {
      const o = n.target;
      !e.contains(o) && e !== o && t.value(n);
    };
    e.clickOutside = a;
    const l = t.modifiers.mousedown ? "mousedown" : "click";
    document.addEventListener(l, (n) => {
      var o;
      return (o = e.clickOutside) == null ? void 0 : o.call(e, n);
    }), document.addEventListener("touchstart", (n) => {
      var o;
      return (o = e.clickOutside) == null ? void 0 : o.call(e, n);
    });
  },
  unmounted(e, t) {
    if (!e.clickOutside) return;
    const a = t.modifiers.mousedown ? "mousedown" : "click";
    document.removeEventListener(a, (l) => {
      var n;
      return (n = e.clickOutside) == null ? void 0 : n.call(e, l);
    }), document.removeEventListener("touchstart", (l) => {
      var n;
      return (n = e.clickOutside) == null ? void 0 : n.call(e, l);
    }), delete e.clickOutside;
  }
}, $n = {
  key: 1,
  class: "visually-hidden"
}, Sn = {
  name: "MDBDropdownToggle"
}, Wr = /* @__PURE__ */ A({
  ...Sn,
  props: {
    ...Ca.props,
    tag: {
      type: String,
      default: "button"
    },
    href: [String, null],
    split: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    const t = e, a = f(() => [
      l.value,
      "dropdown-toggle",
      t.split && "dropdown-toggle-split",
      t.size && `btn-${t.size}`,
      t.outline && `btn-outline-${t.outline}`
    ]), l = f(() => t.tag !== "button" ? void 0 : `btn ${t.color && !t.outline ? `btn-${t.color}` : t.outline ? "" : "btn-primary"}`), n = p(!1), o = () => {
      n.value = !n.value;
    }, r = Z("isPopperActive");
    fe(() => {
      n.value = r ? r.value : !1;
    });
    const s = Z("handleEscAndOutsideClick"), u = (c) => {
      const i = c.target;
      r && !i.closest(".dropdown-menu") && (s == null || s());
    };
    return (c, i) => ke((d(), V(N(e.tag), {
      type: "button",
      class: g(a.value),
      "aria-expanded": n.value,
      "aria-haspopup": "true",
      onClick: o,
      "data-trigger": ""
    }, {
      default: D(() => [
        e.split ? (d(), b("span", $n, "Toggle Dropdown")) : O(c.$slots, "default", { key: 0 })
      ]),
      _: 3
    }, 8, ["class", "aria-expanded"])), [
      [q(Ze), u],
      [q(it)]
    ]);
  }
}), xn = {
  key: 0,
  class: "mt-2 mx-2"
}, Cn = {
  key: 0,
  class: "mt-2 mx-2"
}, Mn = {
  name: "MDBDropdownMenu",
  inheritAttrs: !1
}, Hr = /* @__PURE__ */ A({
  ...Mn,
  props: {
    tag: {
      type: String,
      default: "ul"
    },
    fadeIn: {
      type: String,
      default: "fade-in"
    },
    fadeOut: {
      type: String,
      default: "fade-out"
    },
    animation: {
      type: Boolean,
      default: !0
    },
    dark: {
      type: Boolean,
      default: !1
    },
    static: {
      type: Boolean,
      default: !1
    },
    filter: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    const t = e, a = Qe() ? 0 : 550, l = f(() => [
      "dropdown-menu",
      n === "dropdown-menu-start" ? "dropdown-menu-start" : n.value,
      r.value,
      s.value && "show",
      t.dark && "dropdown-menu-dark"
    ]), n = Z(
      "menuAlignClasses",
      "dropdown-menu-start"
    ), o = p("root"), r = p(null), s = p(!1), u = f(() => t.static ? { display: "block", position: "static" } : !1), c = () => {
      t.animation && setTimeout(() => {
        r.value = !1;
      }, a);
    }, i = Z("setMenuMountedState", () => !1), m = Z("isActive", !1);
    m && ee(
      () => m.value,
      (F) => {
        F ? setTimeout(
          () => {
            i(!0, o.value);
          },
          Qe() ? 0 : 100
        ) : !F && k && ($(), setTimeout(() => {
          i(!1);
        }, a));
      }
    );
    const $ = () => {
      ae(document, "keydown", I), M.value = 0, r.value = t.animation && `animation ${t.fadeOut}`, s.value = !1, c();
    }, v = f(() => t.static || m && m.value || m && !m.value && k && k.value ? !0 : (m && !m.value && k && !k.value && setTimeout(() => !1, a), !1)), y = Z("externalTarget", !1), S = p(!1), h = p("");
    de(() => {
      y && document.body.querySelector(y) && (S.value = !0, h.value = y);
    });
    const k = Z("isPopperActive", null), L = () => {
      ne(document, "keydown", I), r.value = t.animation && `animation ${t.fadeIn}`, c();
    };
    k && ee(
      () => k.value,
      (F, E) => {
        o.value && (!E && F === !0 || E === !1) && (w.value = o.value.querySelectorAll(
          ".dropdown-item"
        ), s.value = !0, L());
      }
    );
    const M = p(0), w = p(null), T = Z(
      "handleEscAndOutsideClick",
      () => !1
    ), I = (F) => {
      var P, x;
      const E = F.key;
      if ((E === "ArrowUp" || E === "ArrowDown") && F.preventDefault(), !(m && !m.value)) {
        switch (w.value && w.value.forEach((_) => {
          _.classList.remove("active");
        }), E) {
          case "Escape":
            T();
            return;
          case "Enter":
            w.value && ((P = w.value[M.value - 1]) == null || P.click());
            return;
          case "ArrowUp":
            M.value--, M.value <= 0 && w.value && (M.value = w.value.length);
            break;
          case "ArrowDown":
            M.value++, w.value && M.value > w.value.length && (M.value = 1);
            break;
        }
        w.value && ((x = w.value[M.value - 1]) == null || x.classList.add("active"));
      }
    }, R = p(""), W = p([]), G = () => {
      W.value = [
        ...o.value.querySelectorAll(".dropdown-item")
      ], W.value.forEach((F) => {
        F.style.display = "flex";
      }), R.value && W.value.forEach((F) => {
        var x;
        const E = (x = F.textContent) == null ? void 0 : x.trim().toLowerCase();
        (E == null ? void 0 : E.includes(R.value.toLowerCase())) || (F.style.display = "none");
      });
    };
    return ee(
      () => R.value,
      () => {
        G();
      }
    ), (F, E) => S.value ? (d(), V(ua, {
      key: 1,
      to: h.value
    }, [
      Oe(Ne, null, {
        default: D(() => [
          v.value ? (d(), V(N(e.tag), Q({
            key: 0,
            class: l.value,
            style: u.value
          }, F.$attrs, {
            "data-popper": q(y),
            ref_key: "root",
            ref: o
          }), {
            default: D(() => [
              e.filter ? (d(), b("div", Cn, [
                Oe(q(qt), {
                  modelValue: R.value,
                  "onUpdate:modelValue": E[1] || (E[1] = (P) => R.value = P),
                  role: "searchbox",
                  type: "text",
                  label: "Search"
                }, null, 8, ["modelValue"])
              ])) : C("", !0),
              O(F.$slots, "default")
            ]),
            _: 3
          }, 16, ["class", "style", "data-popper"])) : C("", !0)
        ]),
        _: 3
      })
    ], 8, ["to"])) : (d(), V(Ne, { key: 0 }, {
      default: D(() => [
        v.value ? (d(), V(N(e.tag), Q({
          key: 0,
          class: l.value,
          style: u.value
        }, F.$attrs, {
          "data-popper": "",
          ref_key: "root",
          ref: o
        }), {
          default: D(() => [
            e.filter ? (d(), b("div", xn, [
              Oe(q(qt), {
                modelValue: R.value,
                "onUpdate:modelValue": E[0] || (E[0] = (P) => R.value = P),
                role: "searchbox",
                type: "text",
                label: "Search"
              }, null, 8, ["modelValue"])
            ])) : C("", !0),
            O(F.$slots, "default")
          ]),
          _: 3
        }, 16, ["class", "style"])) : C("", !0)
      ]),
      _: 3
    }));
  }
}), Vn = ["tabindex"], Dn = {
  key: 1,
  class: "dropdown-divider"
}, On = {
  name: "MDBDropdownItem",
  inheritAttrs: !1
}, Gr = /* @__PURE__ */ A({
  ...On,
  props: {
    tag: {
      type: String,
      default: "a"
    },
    to: [String, Object],
    href: String,
    disabled: {
      type: Boolean,
      default: !1
    },
    active: {
      type: Boolean,
      default: !1
    },
    exact: {
      type: Boolean,
      default: !1
    },
    newTab: {
      type: Boolean,
      default: !1
    },
    submenu: {
      type: Boolean,
      default: !1
    },
    submenuIcon: String,
    divider: {
      type: Boolean,
      default: !1
    },
    text: {
      type: Boolean,
      default: !1
    },
    header: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    const t = e, a = f(() => [
      n.value,
      t.disabled ? "disabled" : "",
      t.active ? "active" : "",
      t.submenu && "dropdown-submenu"
    ]), l = f(() => !!(t.to !== void 0 || t.href !== void 0 || t.tag !== "a" || t.text)), n = f(() => t.text ? "dropdown-item-text" : t.header ? "dropdown-header" : "dropdown-item"), o = f(() => t.to ? "router-link" : t.text ? "span" : t.tag), r = f(() => t.newTab ? "_blank" : null), s = Z(
      "handleEscAndOutsideClick",
      () => !1
    );
    return (u, c) => (d(), b("li", {
      tabindex: e.divider ? void 0 : 0
    }, [
      l.value ? (d(), V(N(o.value), Q({ key: 0 }, u.$attrs, {
        to: e.to,
        exact: e.to ? e.exact : null,
        href: e.to ? null : e.href,
        class: a.value,
        target: r.value,
        type: e.tag === "button" ? "button" : null,
        "aria-current": e.active ? !0 : null,
        "aria-disabled": e.disabled ? !0 : null,
        disabled: e.disabled ? !0 : null,
        onClick: q(s)
      }), {
        default: D(() => [
          O(u.$slots, "default")
        ]),
        _: 3
      }, 16, ["to", "exact", "href", "class", "target", "type", "aria-current", "aria-disabled", "disabled", "onClick"])) : e.divider ? (d(), b("hr", Dn)) : O(u.$slots, "default", { key: 2 })
    ], 8, Vn));
  }
}), En = {
  key: 0,
  "data-popper-arrow": "",
  class: "tooltip_arrow"
}, Nn = {
  name: "MDBTooltip"
}, Ur = /* @__PURE__ */ A({
  ...Nn,
  props: {
    tag: {
      type: String,
      default: "span"
    },
    modelValue: Boolean,
    reference: String,
    popover: String,
    options: {
      type: [Object, Function],
      default() {
        return {};
      }
    },
    boundary: {
      type: String,
      default: "clippingParent"
    },
    fallbackPlacements: {
      type: Array,
      default: () => ["top", "right", "bottom", "left"]
    },
    offset: {
      type: String,
      default: "0, 5"
    },
    direction: {
      type: String,
      default: "top",
      validator: (e) => ["top", "right", "bottom", "left"].indexOf(e.toLowerCase()) > -1
    },
    maxWidth: {
      type: Number,
      default: 276
    },
    arrow: {
      type: Boolean,
      default: !1
    },
    disabled: Boolean
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, { setPopper: l, isPopperActive: n, openPopper: o, closePopper: r, getPopperOffset: s } = mt(), u = p(null), c = p(null), i = f(() => `max-width: ${a.maxWidth}px!important`), m = () => {
      const M = a.direction;
      let w = document.querySelector(a.boundary);
      w || (w = a.boundary);
      const T = {
        placement: M,
        modifiers: [
          {
            name: "flip",
            options: {
              fallbackPlacements: a.fallbackPlacements
            }
          },
          {
            name: "preventOverflow",
            options: {
              boundary: w
            }
          },
          {
            name: "offset",
            options: {
              offset: s(a.offset, u.value)
            }
          },
          {
            name: "arrow",
            options: {
              element: ".tooltip_arrow",
              padding: 5
            }
          }
        ]
      };
      return {
        ...T,
        ...typeof a.options == "function" ? a.options(T) : a.options
      };
    }, $ = () => {
      u.value = a.reference ? document.querySelector(a.reference) : u.value, c.value = a.popover ? document.querySelector(a.popover) : c.value;
      const M = m();
      u.value && c.value && l(u.value, c.value, M);
    }, v = p(!1);
    fe(() => {
      if (a.modelValue) {
        if (v.value)
          return;
        je(() => {
          $(), setTimeout(o, 0), setTimeout(() => {
            var M;
            (M = c.value) == null || M.classList.add("show");
          }, 0);
        });
      } else {
        if (!n.value)
          return;
        setTimeout(() => {
          c.value && c.value.classList.remove("show");
        }, 10), v.value = !0, setTimeout(() => {
          r(), v.value = !1;
        }, 150);
      }
    });
    const y = f(() => a.modelValue || !a.modelValue && n.value ? !0 : (!a.modelValue && !n.value, !1)), S = () => {
      !a.disabled && t("update:modelValue", !0);
    }, h = () => {
      !a.disabled && t("update:modelValue", !1);
    }, k = ca(), L = f(() => {
      var w;
      const M = (w = k.tip) == null ? void 0 : w.call(k);
      return !M || M.length === 0 || M.every((T) => !T.children || T.children.length === 0);
    });
    return (M, w) => (d(), b(ge, null, [
      (d(), V(N(e.tag), Q({
        ref_key: "triggerEl",
        ref: u,
        style: { display: "inline-block" }
      }, M.$attrs, {
        onMouseenter: S,
        onMouseleave: h,
        onFocus: S,
        onBlur: h
      }), {
        default: D(() => [
          O(M.$slots, "reference")
        ]),
        _: 3
      }, 16)),
      Oe(Ne, { name: "fade" }, {
        default: D(() => [
          y.value && !L.value ? (d(), b("div", {
            key: 0,
            ref_key: "popperEl",
            ref: c,
            class: g({
              tooltip: !0,
              fade: !0,
              "tooltip-inner": !0
            }),
            style: le([i.value])
          }, [
            O(M.$slots, "tip"),
            e.arrow ? (d(), b("div", En)) : C("", !0)
          ], 4)) : C("", !0)
        ]),
        _: 3
      })
    ], 64));
  }
}), Tn = {
  key: 0,
  class: "popover-header"
}, An = {
  key: 1,
  class: "popover-body"
}, Ln = {
  key: 2,
  "data-popper-arrow": "",
  class: "popover_arrow"
}, _n = {
  name: "MDBPopover"
}, Xr = /* @__PURE__ */ A({
  ..._n,
  props: {
    tag: {
      type: String,
      default: "span"
    },
    modelValue: Boolean,
    reference: String,
    popover: String,
    options: {
      type: [Object, Function],
      default() {
        return {};
      }
    },
    boundary: {
      type: String,
      default: "clippingParent"
    },
    fallbackPlacements: {
      type: Array,
      default: () => ["top", "right", "bottom", "left"]
    },
    offset: {
      type: String,
      default: "0, 5"
    },
    direction: {
      type: String,
      default: "bottom",
      validator: (e) => ["top", "right", "bottom", "left"].indexOf(e.toLowerCase()) > -1
    },
    maxWidth: {
      type: Number,
      default: 276
    },
    arrow: {
      type: Boolean,
      default: !1
    },
    dismissible: {
      type: Boolean,
      default: !1
    },
    hover: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, {
      setPopper: l,
      isPopperActive: n,
      openPopper: o,
      closePopper: r,
      destroyPopper: s,
      getPopperOffset: u
    } = mt(), c = p(null), i = p(null), m = f(() => `max-width: ${a.maxWidth}px!important`), $ = () => a.arrow ? [0, 10] : a.offset, v = () => {
      const w = a.direction;
      let T = document.querySelector(a.boundary);
      T || (T = a.boundary);
      const I = $(), R = {
        placement: w,
        modifiers: [
          {
            name: "flip",
            options: {
              fallbackPlacements: a.fallbackPlacements
            }
          },
          {
            name: "preventOverflow",
            options: {
              boundary: T
            }
          },
          {
            name: "offset",
            options: {
              offset: u(I, c.value)
            }
          },
          {
            name: "arrow",
            options: {
              element: ".popover_arrow",
              padding: 5
            }
          }
        ]
      };
      return {
        ...R,
        ...typeof a.options == "function" ? a.options(R) : a.options
      };
    }, y = () => {
      c.value = a.reference ? document.querySelector(a.reference) : c.value, i.value = a.popover ? document.querySelector(a.popover) : i.value;
      const w = v();
      c.value && i.value && l(c.value, i.value, w);
    };
    fe(() => {
      if (a.modelValue)
        je(() => {
          y(), setTimeout(o, 0), setTimeout(() => {
            var w;
            (w = i.value) == null || w.classList.add("show"), a.hover && i.value && (ne(i.value, "mouseover", h), ne(i.value, "mouseout", k));
          }, 0);
        });
      else {
        if (!n.value)
          return;
        setTimeout(() => {
          i.value && (ae(i.value, "mouseover", h), ae(i.value, "mouseout", k), i.value.classList.remove("show"));
        }, 0), setTimeout(r, 0), s();
      }
    });
    const S = f(() => a.modelValue || !a.modelValue && n.value ? !0 : (!a.modelValue && !n.value, !1)), h = () => {
      t("update:modelValue", !0);
    }, k = () => {
      t("update:modelValue", !1);
    }, L = () => {
      !a.dismissible || !a.modelValue || t("update:modelValue", !1);
    }, M = () => {
      c.value && (ae(c.value, "mouseover", h), ae(c.value, "mouseout", k)), s();
    };
    return de(() => {
      a.hover && c.value && (ne(c.value, "mouseover", h), ne(c.value, "mouseout", k));
    }), $e(() => {
      M();
    }), (w, T) => (d(), b(ge, null, [
      ke((d(), V(N(e.tag), Q({
        ref_key: "triggerEl",
        ref: c,
        style: { display: "inline-block" },
        tabindex: e.dismissible ? 0 : null
      }, w.$attrs), {
        default: D(() => [
          O(w.$slots, "reference")
        ]),
        _: 3
      }, 16, ["tabindex"])), [
        [q(Ze), L]
      ]),
      Oe(Ne, null, {
        default: D(() => [
          S.value && (w.$slots.header || w.$slots.body) ? (d(), b("div", {
            key: 0,
            ref_key: "popperEl",
            ref: i,
            class: g({ popover: !0, fade: !0 }),
            style: le([m.value])
          }, [
            w.$slots.header ? (d(), b("div", Tn, [
              O(w.$slots, "header")
            ])) : C("", !0),
            w.$slots.body ? (d(), b("div", An, [
              O(w.$slots, "body")
            ])) : C("", !0),
            O(w.$slots, "default"),
            e.arrow ? (d(), b("div", Ln)) : C("", !0)
          ], 4)) : C("", !0)
        ]),
        _: 3
      })
    ], 64));
  }
});
function In() {
  const e = p(), t = p(), a = p();
  function l(c) {
    return e.value = c, n(), ne(window, "keydown", s), !0;
  }
  function n() {
    if (!e.value)
      return;
    const c = Array.from(
      e.value.querySelectorAll(
        'button, a, input, select, textarea, [tabindex]:not([tabindex="-1"])'
      )
    ).filter((i) => {
      const m = i instanceof HTMLAnchorElement ? !0 : !i.disabled;
      return !i.classList.contains("ps__thumb-x") && !i.classList.contains("ps__thumb-y") && m;
    });
    c.length !== 0 && (t.value = c[0], a.value = c[c.length - 1], ne(
      a.value,
      "keydown",
      (i) => o(i)
    ));
  }
  function o(c) {
    c.key === "Tab" && (c.preventDefault(), r());
  }
  function r() {
    t.value && t.value.focus();
  }
  function s(c, i = !1) {
    c.key === "Tab" && (c.preventDefault(), r()), !i && ae(window, "keydown", s);
  }
  function u() {
    ae(a.value, "keydown", o);
  }
  return {
    initFocusTrap: l,
    removeFocusTrap: u
  };
}
function Pn(e, t) {
  const a = p("root"), l = p("dialog"), n = p(""), o = p(null), r = p(e.modelValue), s = p(!1), u = p(null);
  fe(() => {
    r.value = e.modelValue, r.value && t("update:modelValue", !0);
  });
  const c = f(() => [
    "modal",
    e.animation && "fade",
    r.value && "show",
    e.staticBackdrop && "modal-static"
  ]), i = f(() => [
    "modal-dialog",
    e.size && "modal-" + e.size,
    e.centered && "modal-dialog-centered",
    e.scrollable && "modal-dialog-scrollable",
    e.fullscreen && S.value,
    e.dialogClasses
  ]), m = f(() => e.removeBackdrop ? !1 : { "background-color": "rgba(0,0,0, 0.5)" }), $ = p(!1), v = f(() => {
    if (!($.value || e.keepOverflow))
      return "overflow: hidden";
  }), y = f(() => e.bgSrc ? { "background-image": `url("${e.bgSrc}")` } : {}), S = f(() => e.fullscreen ? [
    e.fullscreen !== !0 ? `modal-fullscreen-${e.fullscreen}` : "modal-fullscreen"
  ] : !1), h = () => {
    typeof l.value != "string" && L(l.value);
  }, k = () => {
    t("update:modelValue", !1);
  };
  te("closeModal", k);
  const L = (B) => {
    B.style.transform = "scale(1.02)", setTimeout(() => B.style.transform = "scale(1.0)", 300);
  }, M = (B) => {
    B.key === "Escape" && r.value && k();
  }, w = p(null), T = p(0), I = () => {
    const B = document.createElement("div");
    B.className = "modal-scrollbar-measure", document.body.appendChild(B);
    const j = B.getBoundingClientRect().width - B.clientWidth;
    return document.body.removeChild(B), j;
  }, R = () => {
    const B = document.body.getBoundingClientRect();
    w.value = Math.round(B.left + B.right) < window.innerWidth, T.value = w.value ? Number(I().toFixed(2)) : 0;
  }, W = () => {
    document.body.style.paddingRight = "", document.body.classList.remove("modal-open");
  }, G = (B) => {
    const j = B;
    $.value = !1, n.value = "translate(0, -25%)";
    const X = j.childNodes[0];
    X.style.transform = n.value, j.style.opacity = "0", j.style.display = "block", R(), K(), _.value && (document.body.style.paddingRight = `${T.value}px`, j.style.paddingRight = `${T.value}px`, document.body.classList.add("modal-open")), t("show", a.value);
  }, F = (B) => {
    var Y;
    const j = B, X = j.childNodes[0];
    X.style.transform = "translate(0,0)", j.style.opacity = "1", setTimeout(() => {
      $.value = !0, t("shown", a.value);
    }, 400), u.value = a.value, e.keyboard && ne(window, "keyup", M), e.focus && (o.value = In(), (Y = o.value) == null || Y.initFocusTrap(a.value));
  }, E = (B) => {
    const j = B, X = j.childNodes[0];
    X.style.transform = n.value, j.style.opacity = "0", _.value && setTimeout(() => {
      j.style.paddingRight = "", W();
    }, 200), t("hide", u.value), e.keyboard && ae(window, "keyup", M), e.focus && o.value && o.value.removeFocusTrap();
  }, P = () => {
    t("hidden", u.value), $.value = !1;
  }, x = () => !!(document.body.classList.contains("modal-open") && document.body.querySelector(".modal.show"));
  da(() => {
    x() && (W(), document.body.style.overflowY = ""), ae(window, "keyup", M);
  });
  const _ = p(!0), K = () => {
    _.value = document.body.classList.contains("modal-open") ? !!document.querySelector(".modal.non-invasive") : !0;
  };
  return {
    wrapperClass: c,
    dialogClass: i,
    backdropStyle: m,
    backdropOverflowStyle: v,
    computedContentStyle: y,
    root: a,
    dialog: l,
    isActive: r,
    closeModal: k,
    animateStaticBackdrop: h,
    enter: G,
    afterEnter: F,
    beforeLeave: E,
    afterLeave: P,
    scrollbarWidth: T,
    setScrollbar: R,
    shouldOverflow: $,
    thisElement: u,
    handleEscKeyUp: M,
    focusTrap: o,
    dialogTransform: n,
    animateStaticModal: L,
    fullscreenClass: S,
    clickFromBackdrop: s,
    isOnlyNonInvasiveModal: K,
    onlyNonInvasiveModal: _
  };
}
const Fn = {
  name: "MDBModal"
}, Yr = /* @__PURE__ */ A({
  ...Fn,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    modelValue: Boolean,
    size: {
      type: String,
      validator: (e) => ["sm", "lg", "xl"].indexOf(e.toLowerCase()) > -1
    },
    removeBackdrop: {
      type: Boolean,
      default: !1
    },
    staticBackdrop: {
      type: Boolean,
      default: !1
    },
    centered: {
      type: Boolean,
      default: !1
    },
    bgSrc: {
      type: String,
      default: ""
    },
    scrollable: {
      type: Boolean,
      default: !1
    },
    duration: {
      type: Number,
      default: 400
    },
    labelledby: String,
    fullscreen: {
      type: [Boolean, String],
      default: !1
    },
    animation: {
      type: Boolean,
      default: !0
    },
    dialogClasses: {
      type: String
    },
    keyboard: {
      type: Boolean,
      default: !0
    },
    focus: {
      type: Boolean,
      default: !0
    },
    keepOverflow: {
      type: Boolean,
      default: !1
    }
  },
  emits: [
    "show",
    "shown",
    "hide",
    "hidden",
    "update:modelValue"
  ],
  setup(e, { emit: t }) {
    const a = e, {
      wrapperClass: l,
      dialogClass: n,
      backdropStyle: o,
      backdropOverflowStyle: r,
      computedContentStyle: s,
      root: u,
      dialog: c,
      isActive: i,
      closeModal: m,
      animateStaticBackdrop: $,
      enter: v,
      afterEnter: y,
      beforeLeave: S,
      afterLeave: h,
      clickFromBackdrop: k
    } = Pn(a, t);
    return (L, M) => (d(), V(Ne, {
      onEnter: q(v),
      onAfterEnter: q(y),
      onBeforeLeave: q(S),
      onAfterLeave: q(h)
    }, {
      default: D(() => [
        q(i) ? (d(), V(N(e.tag), {
          key: 0,
          ref_key: "root",
          ref: u,
          class: g(q(l)),
          style: le([q(o), q(r)]),
          "aria-hidden": !q(i),
          "aria-modal": q(i) ? !0 : null,
          "aria-labelledby": e.labelledby,
          role: "dialog",
          onMousedown: M[0] || (M[0] = ze((w) => k.value = !0, ["self"])),
          onClick: M[1] || (M[1] = ze(
            () => {
              q(k) && (e.staticBackdrop ? q($)() : (q(m)(), k.value = !1));
            },
            ["self"]
          ))
        }, {
          default: D(() => [
            H("div", {
              class: g(q(n)),
              role: "document",
              ref_key: "dialog",
              ref: c
            }, [
              H("div", {
                class: "modal-content",
                style: le(q(s))
              }, [
                O(L.$slots, "default")
              ], 4)
            ], 2)
          ]),
          _: 3
        }, 40, ["class", "style", "aria-hidden", "aria-modal", "aria-labelledby"])) : C("", !0)
      ]),
      _: 3
    }, 8, ["onEnter", "onAfterEnter", "onBeforeLeave", "onAfterLeave"]));
  }
}), Rn = {
  name: "MDBModalHeader"
}, Kr = /* @__PURE__ */ A({
  ...Rn,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    close: {
      type: Boolean,
      default: !0
    },
    closeWhite: {
      type: Boolean,
      default: !1
    },
    color: String
  },
  setup(e) {
    const t = e, a = Z("closeModal"), l = f(() => ["modal-header", t.color && `bg-${t.color}`]);
    return (n, o) => (d(), V(N(e.tag), {
      class: g(l.value)
    }, {
      default: D(() => [
        O(n.$slots, "default"),
        e.close ? (d(), V(Da, {
          key: 0,
          white: e.closeWhite,
          onClick: ze(q(a), ["prevent"])
        }, null, 8, ["white", "onClick"])) : C("", !0)
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), qn = {
  name: "MDBModalTitle"
}, Jr = /* @__PURE__ */ A({
  ...qn,
  props: {
    tag: {
      type: String,
      default: "h5"
    },
    bold: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    const t = e, a = f(() => ["modal-title", t.bold && "font-weight-bold"]);
    return (l, n) => (d(), V(N(e.tag), {
      class: g(a.value)
    }, {
      default: D(() => [
        O(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), jn = {
  name: "MDBModalBody"
}, Qr = /* @__PURE__ */ A({
  ...jn,
  props: {
    tag: {
      type: String,
      default: "div"
    }
  },
  setup(e) {
    const t = f(() => ["modal-body"]);
    return (a, l) => (d(), V(N(e.tag), {
      class: g(t.value)
    }, {
      default: D(() => [
        O(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), zn = {
  name: "MDBModalFooter"
}, Zr = /* @__PURE__ */ A({
  ...zn,
  props: {
    tag: {
      type: String,
      default: "div"
    }
  },
  setup(e) {
    const t = f(() => ["modal-footer"]);
    return (a, l) => (d(), V(N(e.tag), {
      class: g(t.value)
    }, {
      default: D(() => [
        O(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Wn = {
  name: "MDBAccordion"
}, es = /* @__PURE__ */ A({
  ...Wn,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    modelValue: String,
    stayOpen: Boolean,
    flush: Boolean,
    classes: String,
    borderless: Boolean
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = p(null), n = f(() => [
      "accordion",
      a.flush && "accordion-flush",
      a.classes,
      a.borderless && "accordion-borderless"
    ]), o = p(a.modelValue), r = (s) => {
      o.value = s, t("update:modelValue", s);
    };
    return fe(() => o.value = a.modelValue), te("activeItem", o), te("stayOpen", a.stayOpen), te("setActiveItem", r), (s, u) => (d(), V(N(e.tag), {
      class: g(n.value),
      ref_key: "accordionRef",
      ref: l
    }, {
      default: D(() => [
        O(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Hn = ["aria-controls"], Gn = {
  name: "MDBAccordionItem"
}, ts = /* @__PURE__ */ A({
  ...Gn,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    collapseId: {
      type: String,
      required: !0
    },
    headerTitle: String,
    headerClasses: String,
    bodyClasses: String,
    itemClasses: String,
    icon: String
  },
  setup(e) {
    const t = e, a = p(null), l = f(() => ["accordion-item", t.itemClasses]), n = f(() => ["accordion-header", t.headerClasses]), o = f(() => ["accordion-body", t.bodyClasses]), r = f(() => ["accordion-button", !m.value && "collapsed"]), s = f(() => t.icon ? [t.icon] : !1), u = Z(
      "setActiveItem",
      null
    ), c = Z("activeItem", null), i = Z("stayOpen", !1), m = p((c == null ? void 0 : c.value) === t.collapseId);
    fe(() => {
      i || (m.value = (c == null ? void 0 : c.value) === t.collapseId);
    });
    const $ = () => {
      i ? m.value = !m.value : u && (m.value ? u("") : u(t.collapseId));
    };
    return (v, y) => (d(), V(N(e.tag), {
      class: g(l.value),
      ref_key: "itemRef",
      ref: a
    }, {
      default: D(() => [
        H("h2", {
          class: g(n.value)
        }, [
          H("button", {
            onClick: $,
            class: g(r.value),
            "aria-expanded": "true",
            "aria-controls": e.collapseId,
            type: "button"
          }, [
            s.value ? (d(), b("i", {
              key: 0,
              class: g(s.value)
            }, null, 2)) : C("", !0),
            fa(z(e.headerTitle), 1)
          ], 10, Hn)
        ], 2),
        Oe(fl, {
          id: e.collapseId,
          modelValue: m.value,
          "onUpdate:modelValue": y[0] || (y[0] = (S) => m.value = S)
        }, {
          default: D(() => [
            H("div", {
              class: g(o.value)
            }, [
              O(v.$slots, "default")
            ], 2)
          ]),
          _: 3
        }, 8, ["id", "modelValue"])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Un = {
  name: "MDBIcon"
}, Xn = /* @__PURE__ */ A({
  ...Un,
  props: {
    iconStyle: {
      type: String,
      default: "fas"
    },
    icon: String,
    flag: String,
    size: String,
    fw: Boolean,
    solid: Boolean
  },
  setup(e) {
    const t = e, a = f(() => [
      !t.flag && t.iconStyle,
      t.flag ? `flag flag-${t.flag}` : `fa-${t.icon}`,
      t.size && `fa-${t.size}`,
      t.fw && "fa-fw",
      t.solid && "fa-solid"
    ]);
    return (l, n) => (d(), b("i", {
      class: g(a.value)
    }, [
      O(l.$slots, "default")
    ], 2));
  }
}), Yn = {
  name: "MDBNavbar"
}, as = /* @__PURE__ */ A({
  ...Yn,
  props: {
    tag: {
      type: String,
      default: "nav"
    },
    bg: String,
    dark: {
      type: Boolean,
      default: !1
    },
    light: {
      type: Boolean,
      default: !1
    },
    double: {
      type: Boolean,
      default: !1
    },
    expand: String,
    position: String,
    transparent: {
      type: Boolean,
      default: !1
    },
    scrolling: {
      type: Boolean,
      default: !1
    },
    scrollingOffset: {
      type: Number,
      default: 100
    },
    center: {
      type: Boolean,
      default: !1
    },
    container: {
      type: [Boolean, String],
      default: !1
    },
    classContainer: String,
    classNavbar: String
  },
  setup(e) {
    const t = e, a = f(() => [
      "navbar",
      t.dark && "navbar-dark",
      t.light && "navbar-light",
      t.bg && !t.transparent ? `bg-${t.bg}` : "",
      t.expand ? t.expand === "small" || t.expand === "sm" ? "navbar-expand-sm" : t.expand === "medium" || t.expand === "md" ? "navbar-expand-md" : t.expand === "large" || t.expand === "lg" ? "navbar-expand-lg" : "navbar-expand-xl" : "",
      t.position === "top" ? "fixed-top" : t.position === "bottom" ? "fixed-bottom" : t.position === "sticky" ? "sticky-top" : "",
      t.scrolling && n.value,
      t.double && "double-nav",
      t.center && "justify-content-center",
      t.classNavbar
    ]), l = f(() => t.container ? [
      t.container !== !0 ? `container-${t.container}` : "container-fluid",
      t.classContainer && t.classContainer
    ] : !1), n = p("navbar-scroll"), o = () => {
      window.pageYOffset > t.scrollingOffset ? n.value = "navbar-scroll navbar-scrolled" : n.value = "navbar-scroll";
    }, r = p(null), s = p("nowrap");
    te("navbarFlexWrapValue", s);
    const u = () => {
      if (!r.value) return;
      const c = getComputedStyle(r.value).flexWrap;
      c === "nowrap" ? s.value = "nowrap" : c === "wrap" && (s.value = "wrap");
    };
    return de(() => (getComputedStyle(r.value) && getComputedStyle(r.value).flexWrap === "wrap" ? s.value = "wrap" : s.value = "nowrap", window.addEventListener("resize", () => u()), t.scrolling && window.addEventListener("scroll", o), () => {
      window.removeEventListener("scroll", o);
    })), (c, i) => (d(), V(N(e.tag), {
      ref_key: "navbar",
      ref: r,
      class: g(a.value),
      role: "navigation"
    }, {
      default: D(() => [
        e.container ? (d(), b("div", {
          key: 0,
          class: g(l.value)
        }, [
          O(c.$slots, "default")
        ], 2)) : C("", !0),
        e.container ? C("", !0) : O(c.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Kn = {
  name: "MDBNavbarToggler"
}, ls = /* @__PURE__ */ A({
  ...Kn,
  props: {
    tag: {
      type: String,
      default: "button"
    },
    target: {
      type: String,
      default: "#navbarSupportedContent"
    },
    togglerClass: String,
    togglerIcon: {
      type: String,
      default: "bars"
    },
    togglerSize: {
      type: String,
      default: "1x"
    },
    iconStyle: {
      type: String,
      default: "fas"
    }
  },
  setup(e) {
    const t = e, a = p(!1), l = f(() => ["navbar-toggler", t.togglerClass]), n = () => a.value = !a.value;
    return (o, r) => (d(), V(N(e.tag), {
      class: g(l.value),
      type: "button",
      "aria-controls": e.target,
      "aria-expanded": a.value,
      "aria-label": "Toggle navigation",
      onClick: n
    }, {
      default: D(() => [
        Oe(q(Xn), {
          icon: e.togglerIcon,
          size: e.togglerSize,
          iconStyle: e.iconStyle
        }, null, 8, ["icon", "size", "iconStyle"])
      ]),
      _: 1
    }, 8, ["class", "aria-controls", "aria-expanded"]));
  }
}), Jn = {
  name: "MDBNavbarBrand"
}, ns = /* @__PURE__ */ A({
  ...Jn,
  props: {
    tag: {
      type: String,
      default: "div"
    }
  },
  setup(e) {
    const t = e, a = et(), l = f(() => a.href ? "a" : t.tag);
    return (n, o) => (d(), V(N(l.value), { class: "navbar-brand" }, {
      default: D(() => [
        O(n.$slots, "default")
      ]),
      _: 3
    }));
  }
}), Qn = {
  name: "MDBNavbarNav"
}, os = /* @__PURE__ */ A({
  ...Qn,
  props: {
    tag: {
      type: String,
      default: "ul"
    },
    right: {
      type: Boolean,
      default: !1
    },
    center: {
      type: Boolean,
      default: !1
    },
    vertical: {
      type: Boolean,
      default: !1
    },
    justifyAround: {
      type: Boolean,
      default: !1
    },
    class: String,
    nav: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    const t = e, a = f(() => [
      t.nav ? "nav" : "navbar-nav",
      t.right ? "ms-auto" : t.center ? "justify-content-center w-100" : t.vertical ? "flex-column" : t.justifyAround ? "justify-content-around w-100" : "me-auto",
      t.class && `${t.class}`
    ]);
    return (l, n) => (d(), V(N(e.tag), {
      class: g(a.value)
    }, {
      default: D(() => [
        O(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Zn = ["href", "target"], eo = {
  name: "MDBNavbarItem"
}, rs = /* @__PURE__ */ A({
  ...eo,
  props: {
    tag: {
      type: String,
      default: "li"
    },
    active: {
      type: Boolean,
      default: !1
    },
    disabled: Boolean,
    exact: {
      type: Boolean,
      default: !1
    },
    newTab: {
      type: Boolean,
      default: !1
    },
    to: [Object, String],
    href: String,
    linkClass: String
  },
  setup(e) {
    const t = e, a = f(() => ["nav-item", !t.to && !t.href && t.active && "active"]), l = f(() => [
      "nav-link",
      t.disabled && "disabled",
      t.active && "active",
      t.linkClass
    ]), n = f(() => t.newTab ? "_blank" : "");
    return (o, r) => {
      const s = va("router-link");
      return d(), V(N(t.tag), {
        class: g(a.value)
      }, {
        default: D(() => [
          e.to ? (d(), V(s, {
            key: 0,
            class: g(l.value),
            exact: e.exact,
            to: e.to,
            target: n.value
          }, {
            default: D(() => [
              O(o.$slots, "default")
            ]),
            _: 3
          }, 8, ["class", "exact", "to", "target"])) : e.href ? (d(), b("a", {
            key: 1,
            href: e.href,
            class: g(l.value),
            target: n.value
          }, [
            O(o.$slots, "default")
          ], 10, Zn)) : O(o.$slots, "default", { key: 2 })
        ]),
        _: 3
      }, 8, ["class"]);
    };
  }
}), to = {
  name: "MDBPagination"
}, ss = /* @__PURE__ */ A({
  ...to,
  props: {
    tag: {
      type: String,
      default: "ul"
    },
    circle: {
      type: Boolean,
      default: !1
    },
    lg: {
      type: Boolean,
      default: !1
    },
    sm: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    const t = e, a = f(() => [
      "pagination",
      t.sm && "pagination-sm",
      t.lg && "pagination-lg",
      t.circle && "pagination-circle"
    ]);
    return (l, n) => (d(), V(N(e.tag), {
      class: g(a.value)
    }, {
      default: D(() => [
        O(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), ao = ["href", "tabindex", "aria-disabled"], lo = { "aria-hidden": "true" }, no = /* @__PURE__ */ H("span", { class: "sr-only" }, "Previous", -1), oo = ["href", "tabindex", "aria-disabled"], ro = { "aria-hidden": "true" }, so = /* @__PURE__ */ H("span", { class: "sr-only" }, "Next", -1), io = {
  name: "MDBPageNav"
}, is = /* @__PURE__ */ A({
  ...io,
  props: {
    tag: {
      type: String,
      default: "li"
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    href: {
      type: String,
      default: "#"
    },
    prev: {
      type: Boolean,
      default: !1
    },
    next: {
      type: Boolean,
      default: !1
    },
    icon: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    const t = e, a = f(() => ["page-item", t.disabled && "disabled"]), l = f(() => t.icon ? "«" : "Previous"), n = f(() => t.icon ? "»" : "Next"), o = f(() => t.disabled ? "-1" : "false");
    return (r, s) => (d(), V(N(e.tag), {
      class: g(a.value)
    }, {
      default: D(() => [
        e.prev ? (d(), b("a", {
          key: 0,
          class: "page-link",
          href: e.href,
          tabindex: o.value,
          "aria-disabled": e.disabled,
          "aria-label": "Previous"
        }, [
          H("span", lo, z(l.value), 1),
          no
        ], 8, ao)) : C("", !0),
        e.next ? (d(), b("a", {
          key: 1,
          class: "page-link",
          href: e.href,
          tabindex: o.value,
          "aria-disabled": e.disabled,
          "aria-label": "Next"
        }, [
          H("span", ro, z(n.value), 1),
          so
        ], 8, oo)) : C("", !0)
      ]),
      _: 1
    }, 8, ["class"]));
  }
}), uo = ["href", "aria-label", "aria-disabled", "tabindex"], co = {
  key: 0,
  "aria-hidden": "true"
}, fo = {
  key: 1,
  class: "sr-only"
}, vo = {
  name: "MDBPageItem"
}, us = /* @__PURE__ */ A({
  ...vo,
  props: {
    tag: {
      type: String,
      default: "li"
    },
    active: {
      type: Boolean,
      default: !1
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    href: String,
    icon: {
      type: Boolean,
      defaul: !1
    },
    label: {
      type: String
    }
  },
  setup(e) {
    const t = e, a = f(() => ["page-item", t.active && "active", t.disabled && "disabled"]), l = f(() => t.icon && t.label ? t.label : t.href), n = f(() => t.disabled ? "-1" : " false");
    return (o, r) => (d(), V(N(e.tag), {
      class: g(a.value)
    }, {
      default: D(() => [
        H("a", {
          class: "page-link",
          href: e.href,
          "aria-label": l.value,
          "aria-disabled": e.disabled,
          tabindex: n.value
        }, [
          e.icon ? (d(), b("span", co, [
            O(o.$slots, "default")
          ])) : C("", !0),
          e.icon ? (d(), b("span", fo, z(l.value), 1)) : O(o.$slots, "default", { key: 2 })
        ], 8, uo)
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), po = {
  name: "MDBBreadcrumb"
}, cs = /* @__PURE__ */ A({
  ...po,
  props: {
    tag: {
      type: String,
      default: "ol"
    }
  },
  setup(e) {
    const t = f(() => ["breadcrumb"]);
    return (a, l) => (d(), V(N(e.tag), {
      class: g(t.value)
    }, {
      default: D(() => [
        O(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), mo = {
  name: "MDBBreadcrumbItem"
}, ds = /* @__PURE__ */ A({
  ...mo,
  props: {
    tag: {
      type: String,
      default: "li"
    },
    active: {
      type: Boolean,
      default: !1
    },
    current: {
      type: String,
      default: "page"
    }
  },
  setup(e) {
    const t = e, a = f(() => ["breadcrumb-item", t.active && "active"]), l = f(() => t.active && t.current);
    return (n, o) => (d(), V(N(e.tag), {
      class: g(a.value),
      "aria-current": l.value
    }, {
      default: D(() => [
        O(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "aria-current"]));
  }
}), go = {
  name: "MDBFooter"
}, fs = /* @__PURE__ */ A({
  ...go,
  props: {
    tag: {
      type: String,
      default: "footer"
    },
    bg: {
      type: String,
      default: "light"
    },
    text: [String, Array]
  },
  setup(e) {
    const t = e, a = f(() => {
      const n = t.text;
      return [
        t.bg && t.bg !== "none" && `bg-${t.bg}`,
        t.text && l(n)
      ];
    }), l = (n) => typeof n == "string" ? `text-${n}` : n.map((o) => `text-${o}`.trim()).join(" ");
    return (n, o) => (d(), V(N(e.tag), {
      class: g(a.value)
    }, {
      default: D(() => [
        O(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), ho = {
  name: "MDBTabs"
}, vs = /* @__PURE__ */ A({
  ...ho,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    modelValue: String,
    vertical: {
      type: [Boolean, String],
      default: !1
    }
  },
  emits: [
    "update:modelValue",
    "hide",
    "hidden",
    "show",
    "shown"
  ],
  setup(e, { emit: t }) {
    const a = e, l = p(null), n = p(null), o = p(a.modelValue);
    ee(
      () => a.modelValue,
      (v) => {
        v !== o.value && (o.value = v, r(null, v));
      }
    );
    const r = (v, y) => {
      v || (v = document.body.querySelector(`#tab-${y}`)), l.value && t("hide", { target: l.value, relatedTarget: v }), t("show", { target: v, relatedTarget: l.value }), t("update:modelValue", y), n.value = v, o.value = y;
    }, s = () => {
      t("shown", { target: n.value, relatedTarget: l.value }), l.value = n.value;
    }, u = () => {
      t("hidden", {
        target: l.value,
        relatedTarget: n.value
      });
    };
    te("activeTab", o), te("updateActiveTab", r), te("emitShown", s), te("emitHidden", u);
    const c = p(!1), i = p(window.innerWidth), m = p(null);
    te("isVertical", c);
    const $ = () => {
      i.value = window.innerWidth;
      const v = ta(i.value, [
        "column",
        a.vertical
      ]);
      v !== m.value && (c.value = v === a.vertical, m.value = v);
    };
    return de(() => {
      a.vertical && (a.vertical === !0 ? c.value = !0 : ($(), ne(window, "resize", $)));
    }), $e(() => {
      ae(window, "resize", $);
    }), (v, y) => c.value ? (d(), V(N(e.tag), Q({
      key: 0,
      class: "row"
    }, v.$attrs), {
      default: D(() => [
        O(v.$slots, "default")
      ]),
      _: 3
    }, 16)) : O(v.$slots, "default", { key: 1 });
  }
}), yo = {
  name: "MDBTabNav"
}, ps = /* @__PURE__ */ A({
  ...yo,
  props: {
    tag: {
      type: String,
      default: "ul"
    },
    pills: Boolean,
    justify: Boolean,
    fill: Boolean,
    tabsClasses: String,
    col: {
      type: String,
      default: "3"
    }
  },
  setup(e) {
    const t = e, a = Z("isVertical"), l = f(() => [
      "nav",
      t.pills ? "nav-pills" : "nav-tabs",
      t.justify && "nav-justified",
      t.fill && "nav-fill",
      (a == null ? void 0 : a.value) && "flex-column",
      t.tabsClasses && t.tabsClasses
    ]), n = f(() => [`col-${t.col}`]);
    return (o, r) => q(a) ? (d(), b("div", {
      key: 0,
      class: g(n.value)
    }, [
      (d(), V(N(e.tag), {
        class: g(l.value)
      }, {
        default: D(() => [
          O(o.$slots, "default")
        ]),
        _: 3
      }, 8, ["class"]))
    ], 2)) : (d(), V(N(e.tag), {
      key: 1,
      class: g(l.value)
    }, {
      default: D(() => [
        O(o.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), bo = {
  key: 0,
  class: "nav-item",
  role: "presentation"
}, wo = ["id", "aria-controls", "href", "onClick"], ko = {
  name: "MDBTabItem",
  inheritAttrs: !1
}, ms = /* @__PURE__ */ A({
  ...ko,
  props: {
    tag: {
      type: String,
      default: "a"
    },
    tabId: {
      type: String,
      required: !0
    },
    href: String
  },
  setup(e) {
    const t = e, a = p(null), l = f(() => ["nav-link", s.value && "active"]), n = f(() => `tab-${t.tabId}`), o = f(() => `${t.tabId}`), r = Z("activeTab"), s = p(r && r.value === t.tabId), u = Z("updateActiveTab");
    fe(
      () => s.value = r && r.value === t.tabId
    );
    const c = () => {
      a.value !== void 0 && u && u(a.value, t.tabId);
    };
    return de(() => {
      s.value && u && u(a.value, t.tabId);
    }), (i, m) => e.href ? (d(), b("li", bo, [
      H("a", Q({
        id: n.value,
        ref_key: "item",
        ref: a,
        class: l.value,
        role: "tab",
        "aria-controls": o.value,
        href: e.href
      }, i.$attrs, {
        onClick: ze(c, ["prevent"])
      }), [
        O(i.$slots, "default")
      ], 16, wo)
    ])) : (d(), V(N(e.tag), Q({
      key: 1,
      id: n.value,
      ref_key: "item",
      ref: a,
      class: l.value,
      role: "tab",
      "aria-controls": o.value
    }, i.$attrs, {
      onClick: ze(c, ["prevent"])
    }), {
      default: D(() => [
        O(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["id", "class", "aria-controls", "onClick"]));
  }
}), Bo = {
  name: "MDBTabPane"
}, gs = /* @__PURE__ */ A({
  ...Bo,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    tabId: {
      type: String,
      required: !0
    }
  },
  setup(e) {
    const t = e, a = p(null), l = f(() => [
      "tab-pane fade",
      s.value && "show active"
    ]), n = f(() => `${t.tabId}`), o = f(() => `tab-${t.tabId}`), r = Z("activeTab"), s = p(r && r.value === t.tabId);
    fe(
      () => s.value = r && r.value === t.tabId
    );
    const u = Z("emitShown"), c = Z("emitHidden");
    de(() => {
      s.value && u && u(t.tabId);
    });
    const i = (y) => {
      const S = y;
      S.style.opacity = "1";
    }, m = (y) => {
      const S = y;
      S.style.opacity = "0", u && u(t.tabId);
    }, $ = (y) => {
      const S = y;
      S.style.opacity = "1", c && c(t.tabId);
    }, v = (y) => {
      const S = y;
      S.style.opacity = "0";
    };
    return (y, S) => (d(), V(Ne, {
      duration: 150,
      onEnter: m,
      onAfterEnter: i,
      onBeforeLeave: $,
      onAfterLeave: v
    }, {
      default: D(() => [
        ke((d(), V(N(e.tag), {
          id: n.value,
          ref_key: "item",
          ref: a,
          class: g(l.value),
          role: "tabpanel",
          "aria-labelledby": o.value
        }, {
          default: D(() => [
            O(y.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "class", "aria-labelledby"])), [
          [Wt, s.value]
        ])
      ]),
      _: 3
    }));
  }
}), $o = {
  name: "MDBTabContent",
  inheritAttrs: !1
}, hs = /* @__PURE__ */ A({
  ...$o,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    col: {
      type: String,
      default: "9"
    },
    contentClasses: String
  },
  setup(e) {
    const t = e, a = Z("isVertical", !1), l = f(() => ["tab-content", t.contentClasses && t.contentClasses]), n = f(() => [`col-${t.col}`]);
    return (o, r) => (d(), V(pa, null, [
      q(a) ? (d(), b("div", {
        key: 0,
        class: g(n.value)
      }, [
        (d(), V(N(e.tag), Q({ class: l.value }, o.$attrs), {
          default: D(() => [
            O(o.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"]))
      ], 2)) : (d(), V(N(e.tag), Q({
        key: 1,
        class: l.value
      }, o.$attrs), {
        default: D(() => [
          O(o.$slots, "default")
        ]),
        _: 3
      }, 16, ["class"]))
    ], 1024));
  }
}), So = {
  name: "MDBCol"
}, ys = /* @__PURE__ */ A({
  ...So,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    col: String,
    sm: String,
    md: String,
    lg: String,
    xl: String,
    offset: String,
    offsetSm: String,
    offsetMd: String,
    offsetLg: String,
    offsetXl: String,
    auto: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    const t = e, a = f(() => [
      t.col ? "col-" + t.col : "",
      t.sm ? "col-sm-" + t.sm : "",
      t.md ? "col-md-" + t.md : "",
      t.lg ? "col-lg-" + t.lg : "",
      t.xl ? "col-xl-" + t.xl : "",
      !t.col && !t.sm && !t.md && !t.lg && !t.xl ? "col" : "",
      t.offset ? "offset-" + t.offset : "",
      t.offsetSm ? "offset-sm-" + t.offsetSm : "",
      t.offsetMd ? "offset-md-" + t.offsetMd : "",
      t.offsetLg ? "offset-lg-" + t.offsetLg : "",
      t.offsetXl ? "offset-xl-" + t.offsetXl : "",
      t.auto ? "col-auto" : ""
    ]);
    return (l, n) => (d(), V(N(e.tag), {
      class: g(a.value)
    }, {
      default: D(() => [
        O(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), xo = {
  name: "MDBRow"
}, bs = /* @__PURE__ */ A({
  ...xo,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    start: {
      type: Boolean,
      default: !1
    },
    end: {
      type: Boolean,
      default: !1
    },
    center: {
      type: Boolean,
      default: !1
    },
    between: {
      type: Boolean,
      default: !1
    },
    around: {
      type: Boolean,
      default: !1
    },
    cols: [String, Array]
  },
  setup(e) {
    const t = e, a = f(() => {
      const n = t.cols;
      return [
        "row",
        t.cols && n ? `${l(n)}` : "",
        t.start && "justify-content-start",
        t.end && "justify-content-end",
        t.center && "justify-content-center",
        t.between && "justify-content-between",
        t.around && "justify-content-around"
      ];
    }), l = (n) => typeof n == "string" ? `row-cols-${n}` : n.map((o) => `row-cols-${o}`.trim()).join(" ");
    return (n, o) => (d(), V(N(e.tag), {
      class: g(a.value)
    }, {
      default: D(() => [
        O(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Co = {
  name: "MDBContainer"
}, ws = /* @__PURE__ */ A({
  ...Co,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    sm: {
      type: Boolean,
      default: !1
    },
    md: {
      type: Boolean,
      default: !1
    },
    lg: {
      type: Boolean,
      default: !1
    },
    xl: {
      type: Boolean,
      default: !1
    },
    xxl: {
      type: Boolean,
      default: !1
    },
    fluid: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    const t = e, a = f(() => [
      t.fluid ? "container-fluid" : "",
      t.sm ? "container-sm" : "",
      t.md ? "container-md" : "",
      t.lg ? "container-lg" : "",
      t.xl ? "container-xl" : "",
      t.xxl ? "container-xxl" : "",
      !t.fluid && !t.sm && !t.md && !t.lg && !t.xl && !t.xxl ? "container" : ""
    ]);
    return (l, n) => (d(), V(N(e.tag), {
      class: g(a.value)
    }, {
      default: D(() => [
        O(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Mo = {
  name: "MDBTable",
  inheritAttrs: !1
}, ks = /* @__PURE__ */ A({
  ...Mo,
  props: {
    tag: {
      type: String,
      default: "table"
    },
    variant: String,
    dark: {
      type: Boolean,
      default: !1
    },
    light: {
      type: Boolean,
      default: !1
    },
    border: {
      type: [Boolean, String],
      default: !1
    },
    borderless: {
      type: Boolean,
      default: !1
    },
    striped: {
      type: Boolean,
      default: !1
    },
    hover: {
      type: Boolean,
      default: !1
    },
    responsive: {
      type: [Boolean, String],
      default: !1
    },
    align: String,
    sm: {
      type: Boolean,
      default: !1
    },
    tableStyle: String,
    captionTop: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    const t = e, a = f(() => t.responsive ? t.responsive !== !0 ? `table-responsive-${t.responsive}` : "table-responsive" : !1), l = f(() => t.border ? t.border !== !0 ? `table-bordered border-${t.border}` : "table-bordered" : ""), n = f(() => [
      "table",
      t.dark && "table-dark",
      t.light && "table-light",
      t.variant && `table-${t.variant}`,
      t.striped && "table-striped",
      l.value,
      t.borderless && "table-borderless",
      t.hover && "table-hover",
      t.sm && "table-sm",
      t.align && t.align === "top" ? "align-top" : t.align === "bottom" ? "align-bottom" : t.align === "middle" ? "align-middle" : "",
      t.captionTop && "caption-top",
      t.tableStyle
    ]);
    return (o, r) => e.responsive ? (d(), b("div", {
      key: 0,
      class: g(a.value)
    }, [
      (d(), V(N(e.tag), Q({
        class: n.value,
        style: e.tableStyle
      }, o.$attrs), {
        default: D(() => [
          O(o.$slots, "default")
        ]),
        _: 3
      }, 16, ["class", "style"]))
    ], 2)) : (d(), V(N(e.tag), Q({
      key: 1,
      class: n.value,
      style: e.tableStyle
    }, o.$attrs), {
      default: D(() => [
        O(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class", "style"]));
  }
}), Vo = ["id", "value"], Do = ["for"], Oo = {
  key: 2,
  class: "form-helper"
}, Eo = {
  key: 3,
  class: "form-helper"
}, No = { class: "form-counter" }, To = /* @__PURE__ */ H("div", { class: "form-notch-trailing" }, null, -1), Ao = ["id", "value"], Lo = ["for"], _o = {
  key: 1,
  class: "form-helper"
}, Io = {
  key: 2,
  class: "form-helper"
}, Po = { class: "form-counter" }, Fo = /* @__PURE__ */ H("div", { class: "form-notch-trailing" }, null, -1), Ro = {
  key: 9,
  class: "form-text"
}, qo = {
  name: "MDBInput",
  inheritAttrs: !1
}, qt = /* @__PURE__ */ A({
  ...qo,
  props: {
    id: String,
    label: String,
    labelClass: String,
    modelValue: [String, Number, Date],
    size: String,
    formOutline: {
      type: Boolean,
      default: !0
    },
    wrapperClass: String,
    inputGroup: {
      type: [Boolean, String],
      default: !1
    },
    wrap: {
      type: Boolean,
      default: !0
    },
    formText: String,
    white: Boolean,
    validationEvent: String,
    isValidated: Boolean,
    isValid: Boolean,
    validFeedback: String,
    invalidFeedback: String,
    tooltipFeedback: {
      type: Boolean,
      default: !1
    },
    tag: {
      type: String,
      default: "div"
    },
    helper: String,
    counter: Boolean,
    maxlength: {
      type: Number,
      default: 0
    }
  },
  emits: ["update:modelValue", "click-outside", "on-validate"],
  setup(e, { expose: t, emit: a }) {
    const l = e, n = et(), o = p(null), r = p(l.modelValue), s = p(null), u = p(!1), c = p(9), i = p(0), m = l.id || xe("MDBInput-"), $ = p(!1), v = f(() => [
      l.formOutline && "form-outline",
      k.value,
      l.white && "form-white",
      l.wrapperClass
    ]), y = f(() => [
      "form-control",
      l.size ? `form-control-${l.size}` : l.inputGroup && l.inputGroup !== !0 && `form-control-${l.inputGroup}`,
      (r.value || r.value === 0) && "active",
      u.value && "placeholder-active",
      T.value && I.value && "is-valid",
      T.value && !I.value && "is-invalid",
      x.value && S()
    ]), S = () => x.value ? r.value || r.value === 0 || $.value ? "opacity-1" : "opacity-0" : "", h = f(() => ["form-label", l.labelClass]), k = f(() => {
      if (l.inputGroup)
        return l.inputGroup !== !0 ? `input-group input-group-${l.inputGroup}` : "input-group";
    }), L = f(() => l.inputGroup && T.value ? { marginBottom: "1rem" } : ""), M = f(() => l.tooltipFeedback ? "valid-tooltip" : "valid-feedback"), w = f(() => l.tooltipFeedback ? "invalid-tooltip" : "invalid-feedback"), T = p(l.isValidated), I = p(l.isValid), R = p(""), W = f(() => T.value && !I.value && l.validationEvent ? R.value : l.invalidFeedback), G = (U) => {
      const J = U.target;
      I.value = J.checkValidity(), I.value || (R.value = J.validationMessage), T.value = !0, a("on-validate", I.value);
    }, F = () => {
      l.validationEvent !== "submit" && o.value && l.validationEvent && ne(o.value, l.validationEvent, G);
    };
    function E() {
      s.value && (i.value = s.value.clientWidth * 0.8 + 8);
    }
    const P = f(() => l.label && s.value && i.value === 8 && s.value.textContent !== ""), x = f(() => [
      "date",
      "time",
      "datetime-local",
      "month",
      "week"
    ].includes(n.type));
    function _() {
      n.placeholder && !s.value ? u.value = !0 : u.value = !1;
    }
    const K = p(null);
    K.value = typeof r.value == "string" && r.value ? r.value.length : 0;
    function B(U) {
      const J = U.target;
      if (l.maxlength && J.value.length > l.maxlength && typeof r.value == "string") {
        J.value = r.value;
        return;
      }
      K.value = J.value.length, r.value = J.value, a("update:modelValue", r.value);
    }
    function j() {
      be(!0), $.value = !0, l.label && P.value && E();
    }
    function X() {
      be(), $.value = !1;
    }
    function Y() {
      a("click-outside");
    }
    const se = p(null), ie = p(null), ue = (U) => {
      ie.value && ie.value.forEach(
        (J) => J.style.opacity = U ? "0" : "1"
      ), U && se.value && (se.value.style.opacity = "1");
    }, Te = n.type && n.type === "date", be = (U = !1) => {
      var J;
      l.label && l.formOutline && ie.value && ((J = ie.value) == null ? void 0 : J.length) > 1 && ue(U), Te && o.value && (o.value.type = U ? "date" : "text");
    }, we = (U) => ![...U.parentNode.children].findIndex(
      (J) => J === U
    );
    return de(() => {
      var U;
      if (E(), _(), be(), l.label && l.formOutline && o.value && (ie.value = ((U = o.value.parentNode) == null ? void 0 : U.querySelectorAll(".form-notch")) || null), l.label && l.formOutline && s.value && o.value && !we(o.value)) {
        const J = parseFloat(getComputedStyle(s.value).left);
        s.value.style.left = `${J + o.value.offsetLeft}px`, c.value += o.value.offsetLeft;
      }
      l.validationEvent && F();
    }), Ht(() => {
      E(), _();
    }), $e(() => {
      o.value && l.validationEvent && ae(o.value, l.validationEvent, G);
    }), fe(() => {
      var U, J;
      if (typeof l.modelValue == "string") {
        if (l.maxlength && ((U = l.modelValue) == null ? void 0 : U.length) > l.maxlength) {
          r.value = l.modelValue.slice(0, l.maxlength), K.value = l.maxlength;
          return;
        }
        K.value = ((J = l.modelValue) == null ? void 0 : J.length) || 0;
      }
      r.value = l.modelValue;
    }), ee(
      () => l.isValidated,
      (U) => T.value = U
    ), ee(
      () => l.isValid,
      (U) => I.value = U
    ), t({
      inputRef: o
    }), (U, J) => (d(), b(ge, null, [
      e.wrap ? C("", !0) : ke((d(), b("input", Q({
        key: 0,
        class: y.value,
        id: q(m),
        value: r.value
      }, U.$attrs, {
        onInput: B,
        ref_key: "inputRef",
        ref: o,
        onFocus: j,
        onBlur: X
      }), null, 16, Vo)), [
        [q(Ze), Y]
      ]),
      e.label && !e.wrap ? (d(), b("label", {
        key: 1,
        ref_key: "labelRef",
        ref: s,
        class: g(h.value),
        for: q(m)
      }, z(e.label), 11, Do)) : C("", !0),
      !e.wrap && e.helper ? (d(), b("div", Oo, z(e.helper), 1)) : C("", !0),
      !e.wrap && e.counter ? (d(), b("div", Eo, [
        H("div", No, z(K.value) + " / " + z(e.maxlength), 1)
      ])) : C("", !0),
      e.wrap ? C("", !0) : O(U.$slots, "default", { key: 4 }),
      !e.wrap && e.validFeedback ? (d(), b("div", {
        key: 5,
        class: g(M.value)
      }, z(e.validFeedback), 3)) : C("", !0),
      !e.wrap && W.value ? (d(), b("div", {
        key: 6,
        class: g(w.value)
      }, z(W.value), 3)) : C("", !0),
      !e.wrap && e.formOutline ? (d(), b("div", {
        key: 7,
        class: "form-notch",
        ref_key: "notchRef",
        ref: se
      }, [
        H("div", {
          class: "form-notch-leading",
          style: le({ width: `${c.value}px` })
        }, null, 4),
        H("div", {
          class: "form-notch-middle",
          style: le({ width: `${i.value}px` })
        }, null, 4),
        To
      ], 512)) : C("", !0),
      e.wrap ? ke((d(), V(N(e.tag), {
        key: 8,
        class: g(v.value),
        style: le(L.value)
      }, {
        default: D(() => [
          O(U.$slots, "prepend"),
          H("input", Q({ class: y.value }, U.$attrs, {
            id: q(m),
            value: r.value,
            onInput: B,
            ref_key: "inputRef",
            ref: o,
            onFocus: j,
            onBlur: X
          }), null, 16, Ao),
          e.label ? (d(), b("label", {
            key: 0,
            ref_key: "labelRef",
            ref: s,
            class: g(h.value),
            for: q(m)
          }, z(e.label), 11, Lo)) : C("", !0),
          e.helper ? (d(), b("div", _o, z(e.helper), 1)) : C("", !0),
          e.counter ? (d(), b("div", Io, [
            H("div", Po, z(K.value) + " / " + z(e.maxlength), 1)
          ])) : C("", !0),
          O(U.$slots, "default"),
          e.validFeedback ? (d(), b("div", {
            key: 3,
            class: g(M.value)
          }, z(e.validFeedback), 3)) : C("", !0),
          W.value ? (d(), b("div", {
            key: 4,
            class: g(w.value)
          }, z(W.value), 3)) : C("", !0),
          e.formOutline ? (d(), b("div", {
            key: 5,
            class: "form-notch",
            ref_key: "notchRef",
            ref: se
          }, [
            H("div", {
              class: "form-notch-leading",
              style: le({ width: `${c.value}px` })
            }, null, 4),
            H("div", {
              class: "form-notch-middle",
              style: le({ width: `${i.value}px` })
            }, null, 4),
            Fo
          ], 512)) : C("", !0)
        ]),
        _: 3
      }, 8, ["class", "style"])), [
        [q(Ze), Y]
      ]) : C("", !0),
      e.formText ? (d(), b("div", Ro, z(e.formText), 1)) : C("", !0)
    ], 64));
  }
}), jo = ["id", "value", "rows"], zo = ["for"], Wo = {
  key: 2,
  class: "form-helper"
}, Ho = {
  key: 3,
  class: "form-helper"
}, Go = { class: "form-counter" }, Uo = ["id", "value", "rows"], Xo = ["for"], Yo = {
  key: 1,
  class: "form-helper"
}, Ko = {
  key: 2,
  class: "form-helper"
}, Jo = { class: "form-counter" }, Qo = {
  key: 5,
  class: "form-notch"
}, Zo = /* @__PURE__ */ H("div", { class: "form-notch-trailing" }, null, -1), er = {
  key: 8,
  class: "form-text"
}, tr = {
  name: "MDBTextarea",
  inheritAttrs: !1
}, Bs = /* @__PURE__ */ A({
  ...tr,
  props: {
    id: String,
    rows: {
      type: [String, Number],
      default: 4
    },
    label: String,
    modelValue: [String, Number],
    size: String,
    formOutline: {
      type: Boolean,
      default: !0
    },
    wrapperClass: String,
    inputGroup: {
      type: [Boolean, String],
      default: !1
    },
    wrap: {
      type: Boolean,
      default: !0
    },
    formText: String,
    white: Boolean,
    validationEvent: String,
    isValidated: Boolean,
    isValid: Boolean,
    validFeedback: String,
    invalidFeedback: String,
    tooltipFeedback: {
      type: Boolean,
      default: !1
    },
    tag: {
      type: String,
      default: "div"
    },
    helper: String,
    counter: Boolean,
    maxLength: {
      type: Number,
      default: 0
    }
  },
  emits: ["update:modelValue", "on-validate"],
  setup(e, { emit: t }) {
    const a = e, l = et(), n = p(null), o = p(a.modelValue), r = p(null), s = p(!1), u = p(9), c = p(0), i = a.id || xe("MDBTextarea-"), m = f(() => [
      a.formOutline && "form-outline",
      v.value,
      a.white && "form-white",
      a.wrapperClass
    ]), $ = f(() => [
      "form-control",
      a.size && `form-control-${a.size}`,
      o.value && "active",
      s.value && "placeholder-active",
      k.value && L.value && "is-valid",
      k.value && !L.value && "is-invalid"
    ]), v = f(() => {
      if (a.inputGroup)
        return a.inputGroup !== !0 ? `input-group input-group-${a.inputGroup}` : "input-group";
    }), y = f(() => a.inputGroup && k.value ? { marginBottom: "1rem" } : ""), S = f(() => a.tooltipFeedback ? "valid-tooltip" : "valid-feedback"), h = f(() => a.tooltipFeedback ? "invalid-tooltip" : "invalid-feedback"), k = p(a.isValidated), L = p(a.isValid), M = p(""), w = f(() => k.value && !L.value && a.validationEvent ? M.value : a.invalidFeedback), T = (P) => {
      const x = P.target;
      L.value = x.checkValidity(), L.value || (M.value = x.validationMessage), k.value = !0, t("on-validate", L.value);
    }, I = () => {
      a.validationEvent !== "submit" && n.value && a.validationEvent && ne(n.value, a.validationEvent, T);
    };
    function R() {
      r.value && (c.value = r.value.clientWidth * 0.8 + 8);
    }
    function W() {
      l.placeholder && !r.value ? s.value = !0 : s.value = !1;
    }
    const G = p(null);
    G.value = typeof o.value == "string" && o.value ? o.value.length : 0;
    function F(P) {
      const x = P.target;
      if (a.counter) {
        if (x.value.length > a.maxLength) {
          typeof o.value == "string" && (x.value = o.value);
          return;
        }
        G.value = x.value.length;
      }
      o.value = x.value, t("update:modelValue", o.value);
    }
    const E = (P) => ![...P.parentNode.children].findIndex(
      (x) => x === P
    );
    return de(() => {
      if (R(), W(), a.label && a.formOutline && r.value && n.value && !E(n.value)) {
        const P = parseFloat(getComputedStyle(r.value).left);
        r.value.style.left = `${P + n.value.offsetLeft}px`, u.value += n.value.offsetLeft;
      }
      a.validationEvent && I();
    }), Ht(() => {
      R(), W();
    }), $e(() => {
      n.value && a.validationEvent && ae(n.value, a.validationEvent, T);
    }), fe(() => {
      var P;
      if (a.counter) {
        if (typeof a.modelValue == "string" && ((P = a.modelValue) == null ? void 0 : P.length) > a.maxLength) {
          o.value = a.modelValue.slice(0, a.maxLength), G.value = a.maxLength;
          return;
        }
        G.value = typeof a.modelValue == "string" && a.modelValue ? a.modelValue.length : 0;
      }
      o.value = a.modelValue;
    }), ee(
      () => a.isValidated,
      (P) => k.value = P
    ), ee(
      () => a.isValid,
      (P) => L.value = P
    ), (P, x) => (d(), b(ge, null, [
      e.wrap ? C("", !0) : (d(), b("textarea", Q({
        key: 0,
        class: $.value
      }, P.$attrs, {
        id: q(i),
        value: o.value,
        onInput: F,
        rows: e.rows,
        ref_key: "textareaRef",
        ref: n
      }), null, 16, jo)),
      e.label && !e.wrap ? (d(), b("label", {
        key: 1,
        ref_key: "labelRef",
        ref: r,
        class: "form-label",
        for: q(i)
      }, z(e.label), 9, zo)) : C("", !0),
      !e.wrap && e.helper ? (d(), b("div", Wo, z(e.helper), 1)) : C("", !0),
      !e.wrap && e.counter ? (d(), b("div", Ho, [
        H("div", Go, z(G.value) + " / " + z(e.maxLength), 1)
      ])) : C("", !0),
      e.wrap ? C("", !0) : O(P.$slots, "default", { key: 4 }),
      !e.wrap && e.validFeedback ? (d(), b("div", {
        key: 5,
        class: g(S.value)
      }, z(e.validFeedback), 3)) : C("", !0),
      !e.wrap && w.value ? (d(), b("div", {
        key: 6,
        class: g(h.value)
      }, z(w.value), 3)) : C("", !0),
      e.wrap ? (d(), V(N(e.tag), {
        key: 7,
        class: g(m.value),
        style: le(y.value)
      }, {
        default: D(() => [
          O(P.$slots, "prepend"),
          H("textarea", Q({ class: $.value }, P.$attrs, {
            id: q(i),
            value: o.value,
            onInput: F,
            rows: e.rows,
            ref_key: "textareaRef",
            ref: n
          }), null, 16, Uo),
          e.label ? (d(), b("label", {
            key: 0,
            ref_key: "labelRef",
            ref: r,
            class: "form-label",
            for: q(i)
          }, z(e.label), 9, Xo)) : C("", !0),
          e.helper ? (d(), b("div", Yo, z(e.helper), 1)) : C("", !0),
          e.counter ? (d(), b("div", Ko, [
            H("div", Jo, z(G.value) + " / " + z(e.maxLength), 1)
          ])) : C("", !0),
          e.validFeedback ? (d(), b("div", {
            key: 3,
            class: g(S.value)
          }, z(e.validFeedback), 3)) : C("", !0),
          w.value ? (d(), b("div", {
            key: 4,
            class: g(h.value)
          }, z(w.value), 3)) : C("", !0),
          e.formOutline ? (d(), b("div", Qo, [
            H("div", {
              class: "form-notch-leading",
              style: le({ width: `${u.value}px` })
            }, null, 4),
            H("div", {
              class: "form-notch-middle",
              style: le({ width: `${c.value}px` })
            }, null, 4),
            Zo
          ])) : C("", !0)
        ]),
        _: 3
      }, 8, ["class", "style"])) : C("", !0),
      e.formText ? (d(), b("div", er, z(e.formText), 1)) : C("", !0)
    ], 64));
  }
}), ar = ["id", "checked", "required", "aria-required"], lr = ["for", "innerHTML"], nr = ["id", "checked", "required", "aria-required"], or = ["for", "innerHTML"], rr = {
  name: "MDBCheckbox",
  inheritAttrs: !1
}, $s = /* @__PURE__ */ A({
  ...rr,
  props: {
    id: String,
    label: String,
    modelValue: Boolean,
    inline: Boolean,
    wrapperClass: String,
    labelClass: String,
    inputClass: String,
    btnCheck: Boolean,
    required: Boolean,
    validateOnChange: Boolean,
    isValidated: Boolean,
    isValid: Boolean,
    validFeedback: String,
    invalidFeedback: String,
    tooltipFeedback: {
      type: Boolean,
      default: !1
    },
    wrap: {
      type: Boolean,
      default: !0
    },
    formCheck: {
      type: Boolean,
      default: !0
    },
    tag: {
      type: String,
      default: "div"
    }
  },
  emits: ["update:modelValue", "on-validate"],
  setup(e, { emit: t }) {
    const a = e, l = p("inputRef"), n = p(a.modelValue), o = a.id || xe("MDBCheckbox-"), r = f(() => [
      a.formCheck && !a.btnCheck ? "form-check" : "",
      a.inline && "form-check-inline",
      a.wrapperClass
    ]), s = f(() => [
      a.btnCheck ? "btn-check" : "form-check-input",
      a.inputClass && a.inputClass,
      m.value && $.value && "is-valid",
      m.value && !$.value && "is-invalid"
    ]), u = f(() => [a.labelClass || "form-check-label"]), c = f(() => a.tooltipFeedback ? "valid-tooltip" : "valid-feedback"), i = f(() => a.tooltipFeedback ? "invalid-tooltip" : "invalid-feedback"), m = p(a.isValidated), $ = p(a.isValid), v = (h) => {
      const k = h.target;
      $.value = k.checkValidity(), m.value = !0, t("on-validate", $.value);
    }, y = () => {
      ne(l.value, "change", v);
    };
    function S() {
      n.value = !n.value, t("update:modelValue", n.value);
    }
    return de(() => {
      a.validateOnChange && y();
    }), $e(() => {
      ae(l.value, "change", v);
    }), fe(() => n.value = a.modelValue), ee(
      () => a.isValidated,
      (h) => m.value = h
    ), ee(
      () => a.isValid,
      (h) => $.value = h
    ), (h, k) => (d(), b(ge, null, [
      e.wrap ? (d(), V(N(e.tag), {
        key: 0,
        class: g(r.value)
      }, {
        default: D(() => [
          H("input", Q({
            class: s.value,
            type: "checkbox"
          }, h.$attrs, {
            id: q(o),
            checked: n.value,
            onChange: S,
            required: e.required ? !0 : void 0,
            "aria-required": e.required,
            ref_key: "inputRef",
            ref: l
          }), null, 16, ar),
          e.label ? (d(), b("label", {
            key: 0,
            class: g(u.value),
            for: q(o),
            innerHTML: e.label
          }, null, 10, lr)) : C("", !0),
          e.validFeedback ? (d(), b("div", {
            key: 1,
            class: g(c.value)
          }, z(e.validFeedback), 3)) : C("", !0),
          e.invalidFeedback ? (d(), b("div", {
            key: 2,
            class: g(i.value)
          }, z(e.invalidFeedback), 3)) : C("", !0)
        ]),
        _: 1
      }, 8, ["class"])) : C("", !0),
      e.wrap ? C("", !0) : (d(), b("input", Q({
        key: 1,
        class: s.value,
        type: "checkbox"
      }, h.$attrs, {
        id: q(o),
        checked: n.value,
        onChange: S,
        required: e.required ? !0 : void 0,
        "aria-required": e.required,
        ref_key: "inputRef",
        ref: l
      }), null, 16, nr)),
      !e.wrap && e.label ? (d(), b("label", {
        key: 2,
        class: g(u.value),
        for: q(o),
        innerHTML: e.label
      }, null, 10, or)) : C("", !0),
      !e.wrap && e.validFeedback ? (d(), b("div", {
        key: 3,
        class: g(c.value)
      }, z(e.validFeedback), 3)) : C("", !0),
      !e.wrap && e.invalidFeedback ? (d(), b("div", {
        key: 4,
        class: g(i.value)
      }, z(e.invalidFeedback), 3)) : C("", !0)
    ], 64));
  }
}), sr = ["id", "required", "aria-required"], ir = ["for"], ur = ["id", "required", "aria-required"], cr = ["for"], dr = {
  name: "MDBRadio",
  inheritAttrs: !1
}, Ss = /* @__PURE__ */ A({
  ...dr,
  props: {
    id: String,
    label: String,
    inline: Boolean,
    modelValue: String,
    wrapperClass: String,
    labelClass: String,
    btnCheck: Boolean,
    required: Boolean,
    validateOnChange: Boolean,
    isValidated: Boolean,
    isValid: Boolean,
    validFeedback: String,
    invalidFeedback: String,
    tooltipFeedback: {
      type: Boolean,
      default: !1
    },
    wrap: {
      type: Boolean,
      default: !0
    },
    formCheck: {
      type: Boolean,
      default: !0
    },
    tag: {
      type: String,
      default: "div"
    }
  },
  emits: ["update:modelValue", "on-validate"],
  setup(e, { emit: t }) {
    const a = e, l = p("inputRef"), n = p(a.modelValue || !1), o = a.id || xe("MDBRadio-"), r = f(() => [
      a.formCheck && !a.btnCheck ? "form-check" : "",
      a.inline && "form-check-inline",
      a.wrapperClass
    ]), s = f(() => [
      a.btnCheck ? "btn-check" : "form-check-input",
      m.value && $.value && "is-valid",
      m.value && !$.value && "is-invalid"
    ]), u = f(() => [a.labelClass || "form-check-label"]), c = f(() => a.tooltipFeedback ? "valid-tooltip" : "valid-feedback"), i = f(() => a.tooltipFeedback ? "invalid-tooltip" : "invalid-feedback"), m = p(a.isValidated), $ = p(a.isValid), v = (h) => {
      const k = h.target;
      $.value = k.checkValidity(), m.value = !0, t("on-validate", $.value);
    }, y = () => {
      ne(l.value, "change", v);
    };
    function S(h) {
      const k = h.target;
      t("update:modelValue", k.value);
    }
    return de(() => {
      a.validateOnChange && y();
    }), $e(() => {
      ae(l.value, "change", v);
    }), fe(() => n.value = a.modelValue), ee(
      () => a.isValidated,
      (h) => m.value = h
    ), ee(
      () => a.isValid,
      (h) => $.value = h
    ), (h, k) => (d(), b(ge, null, [
      e.wrap ? (d(), V(N(e.tag), {
        key: 0,
        class: g(r.value)
      }, {
        default: D(() => [
          ke(H("input", Q({
            class: s.value,
            type: "radio"
          }, h.$attrs, {
            id: q(o),
            onChange: S,
            "onUpdate:modelValue": k[0] || (k[0] = (L) => n.value = L),
            required: e.required ? !0 : void 0,
            "aria-required": e.required,
            ref_key: "inputRef",
            ref: l
          }), null, 16, sr), [
            [Mt, n.value]
          ]),
          e.label ? (d(), b("label", {
            key: 0,
            class: g(u.value),
            for: q(o)
          }, z(e.label), 11, ir)) : C("", !0),
          e.validFeedback ? (d(), b("div", {
            key: 1,
            class: g(c.value)
          }, z(e.validFeedback), 3)) : C("", !0),
          e.invalidFeedback ? (d(), b("div", {
            key: 2,
            class: g(i.value)
          }, z(e.invalidFeedback), 3)) : C("", !0)
        ]),
        _: 1
      }, 8, ["class"])) : C("", !0),
      e.wrap ? C("", !0) : ke((d(), b("input", Q({
        key: 1,
        class: s.value,
        type: "radio"
      }, h.$attrs, {
        id: q(o),
        onChange: S,
        "onUpdate:modelValue": k[1] || (k[1] = (L) => n.value = L),
        required: e.required ? !0 : void 0,
        "aria-required": e.required,
        ref_key: "inputRef",
        ref: l
      }), null, 16, ur)), [
        [Mt, n.value]
      ]),
      !e.wrap && e.label ? (d(), b("label", {
        key: 2,
        class: g(u.value),
        for: q(o)
      }, z(e.label), 11, cr)) : C("", !0),
      !e.wrap && e.validFeedback ? (d(), b("div", {
        key: 3,
        class: g(c.value)
      }, z(e.validFeedback), 3)) : C("", !0),
      !e.wrap && e.invalidFeedback ? (d(), b("div", {
        key: 4,
        class: g(i.value)
      }, z(e.invalidFeedback), 3)) : C("", !0)
    ], 64));
  }
}), fr = ["for"], vr = ["id"], pr = typeof FileList < "u" ? FileList : Object, mr = {
  name: "MDBFile"
}, xs = /* @__PURE__ */ A({
  ...mr,
  props: {
    id: String,
    inputClass: String,
    invalidFeedback: String,
    isInvalid: Boolean,
    isValid: Boolean,
    isValidated: Boolean,
    label: String,
    labelClass: String,
    modelValue: {
      type: [pr, Array],
      default: () => []
    },
    size: String,
    tooltipFeedback: Boolean,
    validFeedback: String,
    validateOnChange: Boolean
  },
  emits: ["update:modelValue", "on-validate"],
  setup(e, { emit: t }) {
    const a = e, l = a.id || xe("MDBFile-"), n = p(a.modelValue), o = f(() => [
      "form-control",
      a.size && `form-control-${a.size}`,
      c.value && i.value && "is-valid",
      c.value && !i.value && "is-invalid",
      a.inputClass
    ]), r = f(() => ["form-label", a.labelClass]), s = f(() => a.tooltipFeedback ? "valid-tooltip" : "valid-feedback"), u = f(() => a.tooltipFeedback ? "invalid-tooltip" : "invalid-feedback"), c = p(a.isValidated), i = p(a.isValid), m = (v) => {
      const y = v.target;
      y.files && (i.value = y.files.length > 0, c.value = !0, t("on-validate", i.value));
    }, $ = (v) => {
      const y = v.target;
      y.files && (n.value = y.files, t("update:modelValue", n.value), a.validateOnChange && m(v));
    };
    return ee(
      () => a.modelValue,
      (v) => n.value = v
    ), ee(
      () => a.isValidated,
      (v) => c.value = v
    ), ee(
      () => a.isValid,
      (v) => {
        i.value = v;
      }
    ), (v, y) => (d(), b(ge, null, [
      e.label ? (d(), b("label", {
        key: 0,
        class: g(r.value),
        for: q(l)
      }, z(e.label), 11, fr)) : C("", !0),
      H("input", Q({
        type: "file",
        class: o.value
      }, v.$attrs, {
        id: q(l),
        onChange: $
      }), null, 16, vr),
      e.validFeedback ? (d(), b("div", {
        key: 1,
        class: g(s.value)
      }, z(e.validFeedback), 3)) : C("", !0),
      e.invalidFeedback ? (d(), b("div", {
        key: 2,
        class: g(u.value)
      }, z(e.invalidFeedback), 3)) : C("", !0)
    ], 64));
  }
}), gr = ["for"], hr = ["id", "value", "min", "max"], yr = { class: "thumb-value" }, br = {
  name: "MDBRange",
  inheritAttrs: !1
}, Cs = /* @__PURE__ */ A({
  ...br,
  props: {
    id: String,
    inputClass: String,
    label: String,
    labelClass: String,
    max: {
      type: Number,
      default: 100
    },
    min: {
      type: Number,
      default: 0
    },
    modelValue: {
      type: Number,
      default: 50
    },
    tag: {
      type: String,
      default: "div"
    },
    thumb: {
      type: Boolean,
      default: !0
    },
    thumbClass: String,
    wrapperClass: String
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = p(a.modelValue), n = p(a.min), o = p(a.max), r = a.id || xe("MDBRange-"), s = p(!1), u = f(() => ["range", a.wrapperClass]), c = f(() => ["form-range", a.inputClass]), i = f(() => ["form-label", a.labelClass]), m = f(() => ["thumb", s.value && "thumb-active", a.thumbClass]), $ = p(0), v = (h) => {
      const k = h.target;
      l.value = parseFloat(k.value), t("update:modelValue", l.value), S();
    }, y = (h) => {
      s.value = h;
    }, S = () => {
      const k = ((typeof l.value == "string" ? parseFloat(l.value) : l.value) - n.value) * 100 / (o.value - n.value);
      $.value = `calc(${k}% + (${8 - k * 0.15}px))`;
    };
    return je(() => {
      S();
    }), ee(
      () => a.modelValue,
      (h) => {
        l.value = h, S();
      }
    ), (h, k) => (d(), b(ge, null, [
      e.label ? (d(), b("label", {
        key: 0,
        class: g(i.value),
        for: q(r)
      }, z(e.label), 11, gr)) : C("", !0),
      (d(), V(N(e.tag), {
        class: g(u.value)
      }, {
        default: D(() => [
          H("input", Q({
            type: "range",
            class: c.value,
            id: q(r),
            value: l.value,
            min: n.value,
            max: o.value
          }, h.$attrs, {
            onInput: v,
            onMousedown: k[0] || (k[0] = (L) => y(!0)),
            onTouchstart: k[1] || (k[1] = (L) => y(!0)),
            onMouseup: k[2] || (k[2] = (L) => y(!1)),
            onTouchend: k[3] || (k[3] = (L) => y(!1))
          }), null, 16, hr),
          e.thumb ? (d(), b("span", {
            key: 0,
            class: g(m.value),
            style: le({ left: $.value })
          }, [
            H("span", yr, z(l.value), 1)
          ], 6)) : C("", !0)
        ]),
        _: 1
      }, 8, ["class"]))
    ], 64));
  }
}), wr = ["id", "checked"], kr = ["for"], Br = {
  name: "MDBSwitch",
  inheritAttrs: !1
}, Ms = /* @__PURE__ */ A({
  ...Br,
  props: {
    id: String,
    inputClass: String,
    label: String,
    labelClass: String,
    modelValue: {
      type: Boolean,
      default: !1
    },
    tag: {
      type: String,
      default: "div"
    },
    wrapperClass: String
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = p(a.modelValue), n = a.id || xe("MDBSwitch-"), o = f(() => ["form-check form-switch", a.wrapperClass]), r = f(() => ["form-check-input", a.inputClass]), s = f(() => ["form-check-label", a.labelClass]);
    function u() {
      l.value = !l.value, t("update:modelValue", l.value);
    }
    return ee(
      () => a.modelValue,
      (c) => l.value = c
    ), (c, i) => (d(), V(N(e.tag), {
      class: g(o.value)
    }, {
      default: D(() => [
        H("input", Q({
          type: "checkbox",
          class: r.value,
          id: q(n)
        }, c.$attrs, {
          checked: l.value,
          onChange: u
        }), null, 16, wr),
        H("label", {
          class: g(s.value),
          for: q(n)
        }, z(e.label), 11, kr)
      ]),
      _: 1
    }, 8, ["class"]));
  }
}), Vs = {
  mounted(e, t) {
    e.scrollspy = {
      links: [],
      container: window,
      scrollPosition: null,
      async: !1,
      offset: 0
    }, t.value && (e.scrollspy.container = document.getElementById(t.value.container) || window, e.scrollspy.async = t.value.async || !1, e.scrollspy.offset = t.value.offset || 0), e.scrollspy.scrollPosition = jt(e.scrollspy.container), e.scrollspy.findHrefs = (a) => {
      var l;
      if (a.attributes && a instanceof HTMLAnchorElement && a.href) {
        if (e.scrollspy.links.push(a), a.classList.contains("collapsible-scrollspy")) {
          const n = (l = a.parentNode) == null ? void 0 : l.querySelector("ul");
          n.dataset.mdbCollapsibleScrollspyHeight = n.clientHeight.toString(), n.style.overflow = "hidden", n.style.height = "0";
        }
      } else a.childNodes && a.childNodes.forEach(
        (n) => {
          var o, r;
          return (r = (o = e.scrollspy).findHrefs) == null ? void 0 : r.call(o, n);
        }
      );
    }, e.scrollspy.setActive = (a) => {
      if (t.value && t.value.callback) {
        t.instance[t.value.callback](a);
        return;
      }
      e.scrollspy.links.forEach((l, n) => {
        a === n ? l.classList.add("active") : l.classList.remove("active");
      }), $r(e.scrollspy.links, a, e.scrollspy.container), zt(e.scrollspy.links);
    }, e.scrollspy.spy = () => {
      var n, o, r, s;
      if (e.disableScroll) return;
      const a = e.scrollspy.container;
      e.scrollspy.scrollPosition = jt(a), e.scrollspy.links.forEach((u) => {
        const c = document.querySelector(u.hash);
        if (!c)
          return;
        const i = c.getBoundingClientRect();
        let m;
        if (a === window)
          m = window.innerHeight > i.top && i.top + i.height >= 0;
        else if (!(a instanceof Window)) {
          const $ = a.getBoundingClientRect();
          m = i.top <= $.top + $.height && i.top + i.height >= $.top;
        }
        u.isLinkActive = m;
      });
      const l = e.scrollspy.links.filter(
        (u) => u.isLinkActive
      );
      if (l.length > 0) {
        const c = l[0].scrollspyIndex;
        (o = (n = e.scrollspy).setActive) == null || o.call(n, c);
      } else
        (s = (r = e.scrollspy).setActive) == null || s.call(r, -1);
    }, e.scrollspy.clickHandler = (a, l) => {
      var s, u;
      const n = e.scrollspy.container;
      window.clearTimeout(e.disableScrollTimeout), e.disableScroll = !0, a.preventDefault();
      const o = document.querySelector(l.hash);
      if (!o)
        return;
      const r = o.getBoundingClientRect();
      if (n === window)
        window.scrollTo({
          top: window.scrollY + r.y - e.scrollspy.offset
        });
      else if (!(n instanceof Window)) {
        const c = n.getBoundingClientRect();
        n.style.scrollBehavior = "smooth", n.scrollTop = n.scrollTop + r.y - c.y - e.scrollspy.offset;
      }
      (u = (s = e.scrollspy).setActive) == null || u.call(s, l.scrollspyIndex), l.scrollspyIndex && Sr(e.scrollspy.links[l.scrollspyIndex], e), zt(e.scrollspy.links), e.disableScrollTimeout = setTimeout(() => {
        e.disableScroll = !1;
      }, 800);
    }, e.scrollspy.findHrefs(e), e.scrollspy.links.forEach((a, l) => {
      a.scrollspyIndex = l, a.addEventListener(
        "click",
        (n) => {
          var o, r;
          return (r = (o = e.scrollspy).clickHandler) == null ? void 0 : r.call(o, n, a);
        }
      );
    }), e.scrollspy.spy(), e.scrollspy.container.addEventListener(
      "scroll",
      (a) => {
        var l, n;
        return (n = (l = e.scrollspy).spy) == null ? void 0 : n.call(l, a);
      }
    ), window.addEventListener("resize", (a) => {
      var l, n;
      return (n = (l = e.scrollspy).spy) == null ? void 0 : n.call(l, a);
    });
  },
  updated(e, t) {
    var a, l;
    (a = t.modifiers) != null && a.async && t.value && !t.value.loading && ((l = t.oldValue) != null && l.loading) && setTimeout(() => {
      var n, o, r, s;
      e.scrollspy.links = [], (o = (n = e.scrollspy).findHrefs) == null || o.call(n, e), e.scrollspy.links.forEach((u, c) => {
        u.scrollspyIndex = c, u.addEventListener(
          "click",
          (i) => {
            var m, $;
            return ($ = (m = e.scrollspy).clickHandler) == null ? void 0 : $.call(m, i, u);
          }
        );
      }), (s = (r = e.scrollspy).spy) == null || s.call(r);
    }, 0);
  },
  unmounted(e) {
    window.removeEventListener("scroll", (t) => {
      var a, l;
      return (l = (a = e.scrollspy).spy) == null ? void 0 : l.call(a, t);
    }), window.removeEventListener("resize", (t) => {
      var a, l;
      return (l = (a = e.scrollspy).spy) == null ? void 0 : l.call(a, t);
    });
  }
}, $r = (e, t, a) => {
  const l = e[t];
  if (!l || !l.parentNode)
    return;
  const n = Array.from(
    l.parentNode.querySelectorAll("a")
  );
  n.shift(), n.forEach((r) => {
    const s = document.querySelector(r.hash);
    if (!s)
      return;
    const u = s.getBoundingClientRect();
    let c;
    if (a === window)
      c = window.innerHeight > u.top && u.top + u.height >= 0;
    else if (!(a instanceof Window)) {
      const i = a.getBoundingClientRect();
      c = u.top < i.top && u.top + u.height > i.top;
    }
    r.isActive = c;
  });
  const o = n.filter((r) => r.isLinkActive);
  o.length > 0 && o[0].classList.add("active");
}, Sr = (e, t) => {
  var l;
  let a = e.parentNode;
  if (a)
    for (; a && a !== t; )
      a.classList.contains("nav-item") && ((l = a.querySelector("a")) == null || l.classList.add("active")), a = a.parentNode;
}, jt = (e) => e === window ? e.scrollY : e instanceof Window ? null : e.scrollTop, zt = (e) => {
  e.forEach((t) => {
    var a, l;
    if (t.classList.contains("collapsible-scrollspy") && t.classList.contains("active")) {
      const n = (a = t.parentNode) == null ? void 0 : a.querySelector("ul");
      n && (n.style.overflow = "hidden", n.style.height = `${n.dataset.mdbCollapsibleScrollspyHeight}px`);
    } else if (t.classList.contains("collapsible-scrollspy")) {
      const n = (l = t.parentNode) == null ? void 0 : l.querySelector("ul");
      n && (n.style.overflow = "hidden", n.style.height = "0");
    }
  });
};
export {
  es as MDBAccordion,
  ts as MDBAccordionItem,
  Cr as MDBBadge,
  cs as MDBBreadcrumb,
  ds as MDBBreadcrumbItem,
  Ca as MDBBtn,
  Da as MDBBtnClose,
  Mr as MDBBtnGroup,
  Vr as MDBCard,
  Dr as MDBCardBody,
  Ar as MDBCardFooter,
  _r as MDBCardGroup,
  Tr as MDBCardHeader,
  Nr as MDBCardImg,
  Lr as MDBCardLink,
  Er as MDBCardText,
  Or as MDBCardTitle,
  Ir as MDBCarousel,
  $s as MDBCheckbox,
  ys as MDBCol,
  fl as MDBCollapse,
  ws as MDBContainer,
  zr as MDBDropdown,
  Gr as MDBDropdownItem,
  Hr as MDBDropdownMenu,
  Wr as MDBDropdownToggle,
  xs as MDBFile,
  fs as MDBFooter,
  Xn as MDBIcon,
  qt as MDBInput,
  Pr as MDBListGroup,
  Fr as MDBListGroupItem,
  Yr as MDBModal,
  Qr as MDBModalBody,
  Zr as MDBModalFooter,
  Kr as MDBModalHeader,
  Jr as MDBModalTitle,
  as as MDBNavbar,
  ns as MDBNavbarBrand,
  rs as MDBNavbarItem,
  os as MDBNavbarNav,
  ls as MDBNavbarToggler,
  us as MDBPageItem,
  is as MDBPageNav,
  ss as MDBPagination,
  Xr as MDBPopover,
  Rr as MDBProgress,
  qr as MDBProgressBar,
  Ss as MDBRadio,
  Cs as MDBRange,
  bs as MDBRow,
  jr as MDBSpinner,
  Ms as MDBSwitch,
  hs as MDBTabContent,
  ms as MDBTabItem,
  ps as MDBTabNav,
  gs as MDBTabPane,
  ks as MDBTable,
  vs as MDBTabs,
  Bs as MDBTextarea,
  Ur as MDBTooltip,
  Ze as mdbClickOutside,
  it as mdbRipple,
  Vs as mdbScrollspy
};
//# sourceMappingURL=mdb.es.min.js.map
